{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to toolboxv2","text":"<p>**A Python cli to Automate actions cli &amp; api.  **</p> <ul> <li>Free software: Apache Software License 2.0</li> <li>Documentation: https://MarkinHaus.github.io/toolboxv2</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"#credits","title":"Credits","text":"<p>This package was created with Cookiecutter and the giswqs/pypackage project template.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/MarkinHaus/ToolBoxV2/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>ToolBox could always use more documentation, whether as part of the official ToolBox docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/MarkinHaus/ToolBoxV2/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up ToolBoxV2 for local development.</p> <ol> <li> <p>Fork the ToolBoxV2 repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> </li> </ol> <pre><code>$ git clone git@github.com:MarkinHaus/ToolBoxV2.git\n</code></pre> <ol> <li>Install your local copy into a virtualenv. Assuming you have    virtualenvwrapper installed, this is how you set up your fork for    local development:</li> </ol> <pre><code>$ mkvirtualenv ToolBoxV2\n$ cd ToolBoxV2/\n$ python setup.py develop\n</code></pre> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li>When you're done making changes, check that your changes pass flake8    and the tests, including testing other Python versions with tox:</li> </ol> <pre><code>$ flake8 ToolBoxV2 tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.    Put your new functionality into a function with a docstring, and add    the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.5, 3.6, 3.7 and 3.8, and    for PyPy. Check https://github.com/MarkinHaus/ToolBoxV2/pull_requests and make sure that the tests pass for all    supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#gei-isaa-redy-in-conda-with-cuda-conda-install-pytorch-torchvision-torchaudio-pytorch-cuda124-c-pytorch-c-nvidia","title":"Gei isaa redy in conda with cuda  # conda install pytorch torchvision torchaudio pytorch-cuda=12.4 -c pytorch -c nvidia","text":""},{"location":"faq/#errors","title":"Errors :","text":""},{"location":"faq/#modulenotfounderror-no-module-named-_cffi_backend-fix-pip-vvv-install-upgrade-force-reinstall-cffi","title":"ModuleNotFoundError: No module named '_cffi_backend' fix -&gt; pip -vvv install --upgrade --force-reinstall cffi","text":""},{"location":"faq/#extraes-langchain-experimental-pyaudio-pebble-transformers-litellm-gpt4all-speechrecognition-chromadb-pydub-duckduckgo-search-langchain-groq-beautifulsoup4-langchain-huggingface-langchain-langchain-chroma-langchain-ollama","title":"extraes : langchain-experimental PyAudio Pebble transformers litellm  gpt4all SpeechRecognition chromadb pydub duckduckgo-search langchain-groq beautifulsoup4 langchain-huggingface langchain  langchain-chroma langchain-ollama","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install ToolBox, run this command in your terminal:</p> <pre><code>pip install ToolBoxV2\n</code></pre> <p>This is the preferred method to install ToolBox, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>The sources for ToolBox can be downloaded from the Github repo.</p> <p>You can clone the public repository:</p> <pre><code>git clone https://github.com/MarkinHaus/ToolBoxV2\n</code></pre> <p>or with pip</p> <pre><code>pip install git+https://github.com/MarkinHaus/ToolBoxV2\n</code></pre>"},{"location":"toolboxv2/","title":"toolboxv2 module","text":"Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>class App(AppType, metaclass=Singleton):\n\n    def __init__(self, prefix: str = \"\", args=AppArgs().default()):\n        super().__init__(prefix, args)\n        t0 = time.perf_counter()\n        abspath = os.path.abspath(__file__)\n        self.system_flag = system()  # Linux: Linux Mac: Darwin Windows: Windows\n\n        self.appdata = os.getenv('APPDATA') if os.name == 'nt' else os.getenv('XDG_CONFIG_HOME') or os.path.expanduser(\n                '~/.config') if os.name == 'posix' else None\n\n        if self.system_flag == \"Darwin\" or self.system_flag == \"Linux\":\n            dir_name = os.path.dirname(abspath).replace(\"/utils\", \"\")\n        else:\n            dir_name = os.path.dirname(abspath).replace(\"\\\\utils\", \"\")\n\n        os.chdir(dir_name)\n        self.start_dir = str(dir_name)\n\n        lapp = dir_name + '\\\\.data\\\\'\n\n        if not prefix:\n            if not os.path.exists(f\"{lapp}last-app-prefix.txt\"):\n                os.makedirs(lapp, exist_ok=True)\n                open(f\"{lapp}last-app-prefix.txt\", \"a\").close()\n            with open(f\"{lapp}last-app-prefix.txt\", \"r\") as prefix_file:\n                cont = prefix_file.read()\n                if cont:\n                    prefix = cont\n        else:\n            if not os.path.exists(f\"{lapp}last-app-prefix.txt\"):\n                os.makedirs(lapp, exist_ok=True)\n                open(f\"{lapp}last-app-prefix.txt\", \"a\").close()\n            with open(f\"{lapp}last-app-prefix.txt\", \"w\") as prefix_file:\n                prefix_file.write(prefix)\n\n        self.prefix = prefix\n\n        node_ = node()\n\n        if 'localhost' in node_ and (host := os.getenv('HOSTNAME', 'localhost')) != 'localhost':\n            node_ = node_.replace('localhost', host)\n        self.id = prefix + '-' + node_\n        self.globals = {\n            \"root\": {**globals()},\n        }\n        self.locals = {\n            \"user\": {'app': self, **locals()},\n        }\n\n        identification = self.id\n\n        if \"test\" in prefix:\n            if self.system_flag == \"Darwin\" or self.system_flag == \"Linux\":\n                start_dir = self.start_dir.replace(\"ToolBoxV2/toolboxv2\", \"toolboxv2\")\n            else:\n                start_dir = self.start_dir.replace(\"ToolBoxV2\\\\toolboxv2\", \"toolboxv2\")\n            self.data_dir = start_dir + '\\\\.data\\\\' + \"test\"\n            self.config_dir = start_dir + '\\\\.config\\\\' + \"test\"\n            self.info_dir = start_dir + '\\\\.info\\\\' + \"test\"\n        else:\n            self.data_dir = self.start_dir + '\\\\.data\\\\' + identification\n            self.config_dir = self.start_dir + '\\\\.config\\\\' + identification\n            self.info_dir = self.start_dir + '\\\\.info\\\\' + identification\n\n        if self.appdata is None:\n            self.appdata = self.data_dir\n        else:\n            self.appdata += \"/ToolBoxV2\"\n\n        if not os.path.exists(self.appdata):\n            os.makedirs(self.appdata, exist_ok=True)\n        if not os.path.exists(self.data_dir):\n            os.makedirs(self.data_dir, exist_ok=True)\n        if not os.path.exists(self.config_dir):\n            os.makedirs(self.config_dir, exist_ok=True)\n        if not os.path.exists(self.info_dir):\n            os.makedirs(self.info_dir, exist_ok=True)\n\n        print(f\"Starting ToolBox as {prefix} from :\", Style.Bold(Style.CYAN(f\"{os.getcwd()}\")))\n\n        logger_info_str, self.logger, self.logging_filename = self.set_logger(args.debug)\n\n        print(\"Logger \" + logger_info_str)\n        print(\"================================\")\n        self.logger.info(\"Logger initialized\")\n        get_logger().info(Style.GREEN(\"Starting Application instance\"))\n        if args.init and args.init is not None:\n            if self.start_dir not in sys.path:\n                sys.path.append(self.start_dir)\n\n        with open(os.getenv('CONFIG_FILE', f'{dir_name}/toolbox.yaml'), 'r') as config_file:\n            _version = safe_load(config_file)\n            __version__ = _version.get('main', {}).get('version', '-.-.-')\n\n        self.version = __version__\n\n        self.keys = {\n            \"MACRO\": \"macro~~~~:\",\n            \"MACRO_C\": \"m_color~~:\",\n            \"HELPER\": \"helper~~~:\",\n            \"debug\": \"debug~~~~:\",\n            \"id\": \"name-spa~:\",\n            \"st-load\": \"mute~load:\",\n            \"comm-his\": \"comm-his~:\",\n            \"develop-mode\": \"dev~mode~:\",\n            \"provider::\": \"provider::\",\n        }\n\n        defaults = {\n            \"MACRO\": ['Exit'],\n            \"MACRO_C\": {},\n            \"HELPER\": {},\n            \"debug\": args.debug,\n            \"id\": self.id,\n            \"st-load\": False,\n            \"comm-his\": [[]],\n            \"develop-mode\": False,\n        }\n        self.config_fh = FileHandler(self.id + \".config\", keys=self.keys, defaults=defaults)\n        self.config_fh.load_file_handler()\n        self._debug = args.debug\n        self.runnable = {}\n        self.dev_modi = self.config_fh.get_file_handler(self.keys[\"develop-mode\"])\n        if self.config_fh.get_file_handler(\"provider::\") is None:\n            self.config_fh.add_to_save_file_handler(\"provider::\", \"http://localhost:\" + str(\n                self.args_sto.port) if \"localhost\" == os.environ.get(\"HOSTNAME\",\n                                                                     \"localhost\") else \"https://simplecore.app\")\n        self.functions = {}\n        self.modules = {}\n\n        self.interface_type = ToolBoxInterfaces.native\n        self.PREFIX = Style.CYAN(f\"~{node()}@&gt;\")\n        self.alive = True\n        self.called_exit = False, time.time()\n\n        self.print(f\"Infos:\\n  {'Name':&lt;8} -&gt; {node()}\\n  {'ID':&lt;8} -&gt; {self.id}\\n  {'Version':&lt;8} -&gt; {self.version}\\n\")\n\n        self.logger.info(\n            Style.GREEN(\n                f\"Finish init up in {time.perf_counter() - t0:.2f}s\"\n            )\n        )\n\n        self.args_sto = args\n\n        from .system.session import Session\n        self.session: Session = Session(self.get_username())\n\n    def get_username(self, get_input=False):\n        user_name = self.config_fh.get_file_handler(\"ac_user:::\")\n        if get_input and user_name is None and user_name != \"None\":\n            user_name = input(\"Input your username\\nbe sure to make no typos: \")\n            self.config_fh.add_to_save_file_handler(\"ac_user:::\", user_name)\n        if user_name is None:\n            user_name = ''\n        return user_name\n\n    def reset_username(self):\n        self.config_fh.add_to_save_file_handler(\"ac_user:::\", \"None\")\n\n    @staticmethod\n    def exit_main(*args, **kwargs):\n        \"\"\"proxi attr\"\"\"\n\n    @staticmethod\n    def hide_console(*args, **kwargs):\n        \"\"\"proxi attr\"\"\"\n\n    @staticmethod\n    def show_console(*args, **kwargs):\n        \"\"\"proxi attr\"\"\"\n\n    @staticmethod\n    def disconnect(*args, **kwargs):\n        \"\"\"proxi attr\"\"\"\n\n    def set_logger(self, debug=False):\n        if \"test\" in self.prefix and not debug:\n            logger, logging_filename = setup_logging(logging.NOTSET, name=\"toolbox-test\", interminal=True,\n                                                     file_level=logging.NOTSET, app_name=self.id)\n            logger_info_str = \"in Test Mode\"\n        elif \"live\" in self.prefix and not debug:\n            logger, logging_filename = setup_logging(logging.DEBUG, name=\"toolbox-live\", interminal=False,\n                                                     file_level=logging.WARNING, app_name=self.id)\n            logger_info_str = \"in Live Mode\"\n            # setup_logging(logging.WARNING, name=\"toolbox-live\", is_online=True\n            #              , online_level=logging.WARNING).info(\"Logger initialized\")\n        elif \"debug\" in self.prefix or self.prefix.endswith(\"D\"):\n            self.prefix = self.prefix.replace(\"-debug\", '').replace(\"debug\", '')\n            logger, logging_filename = setup_logging(logging.DEBUG, name=\"toolbox-debug\", interminal=True,\n                                                     file_level=logging.WARNING, app_name=self.id)\n            logger_info_str = \"in debug Mode\"\n            self.debug = True\n        elif debug:\n            logger, logging_filename = setup_logging(logging.DEBUG, name=f\"toolbox-{self.prefix}-debug\",\n                                                     interminal=True,\n                                                     file_level=logging.DEBUG, app_name=self.id)\n            logger_info_str = \"in args debug Mode\"\n        else:\n            logger, logging_filename = setup_logging(logging.ERROR, name=f\"toolbox-{self.prefix}\", app_name=self.id)\n            logger_info_str = \"in Default\"\n\n        return logger_info_str, logger, logging_filename\n\n    @property\n    def debug(self):\n        return self._debug\n\n    @debug.setter\n    def debug(self, value):\n        if not isinstance(value, bool):\n            self.logger.debug(f\"Value must be an boolean. is : {value} type of {type(value)}\")\n            raise ValueError(\"Value must be an boolean.\")\n\n        # self.logger.info(f\"Setting debug {value}\")\n        self._debug = value\n\n    def debug_rains(self, e):\n        if self.debug:\n            raise e\n\n    def set_runnable(self, r):\n        self.runnable = r\n\n    async def run_runnable(self, name, **kwargs):\n        from ..runabel import runnable_dict as runnable_dict_func\n        if name not in self.runnable.keys():\n            self.runnable = {**self.runnable, **runnable_dict_func(s=name, remote=True)}\n        if name in self.runnable.keys():\n            if inspect.iscoroutinefunction(self.runnable[name]):\n                return await self.runnable[name](get_app(from_=\"runner\"), self.args_sto, **kwargs)\n            else:\n                return self.runnable[name](get_app(from_=\"runner\"), self.args_sto, **kwargs)\n\n    def _coppy_mod(self, content, new_mod_dir, mod_name, file_type='py'):\n\n        mode = 'xb'\n        self.logger.info(f\" coppy mod {mod_name} to {new_mod_dir} size : {sys.getsizeof(content) / 8388608:.3f} mb\")\n\n        if not os.path.exists(new_mod_dir):\n            os.makedirs(new_mod_dir)\n            with open(f\"{new_mod_dir}/__init__.py\", \"w\") as nmd:\n                nmd.write(f\"__version__ = '{self.version}'\")\n\n        if os.path.exists(f\"{new_mod_dir}/{mod_name}.{file_type}\"):\n            mode = False\n\n            with open(f\"{new_mod_dir}/{mod_name}.{file_type}\", 'rb') as d:\n                runtime_mod = d.read()  # Testing version but not efficient\n\n            if len(content) != len(runtime_mod):\n                mode = 'wb'\n\n        if mode:\n            with open(f\"{new_mod_dir}/{mod_name}.{file_type}\", mode) as f:\n                f.write(content)\n\n    def _pre_lib_mod(self, mod_name, path_to=\"./runtime\", file_type='py'):\n        working_dir = self.id.replace(\".\", \"_\")\n        lib_mod_dir = f\"toolboxv2.runtime.{working_dir}.mod_lib.\"\n\n        self.logger.info(f\"pre_lib_mod {mod_name} from {lib_mod_dir}\")\n\n        postfix = \"_dev\" if self.dev_modi else \"\"\n        mod_file_dir = f\"./mods{postfix}/{mod_name}.{file_type}\"\n        new_mod_dir = f\"{path_to}/{working_dir}/mod_lib\"\n        with open(mod_file_dir, \"rb\") as c:\n            content = c.read()\n        self._coppy_mod(content, new_mod_dir, mod_name, file_type=file_type)\n        return lib_mod_dir\n\n    def _copy_load(self, mod_name, file_type='py', **kwargs):\n        loc = self._pre_lib_mod(mod_name, file_type)\n        return self.inplace_load_instance(mod_name, loc=loc, **kwargs)\n\n    def helper_install_pip_module(self, module_name):\n        if 'main' in self.id:\n            return\n        self.print(f\"Installing {module_name} GREEDY\")\n        os.system(f\"{sys.executable} -m pip install {module_name}\")\n\n    def python_module_import_classifier(self, mod_name, error_message):\n\n        if error_message.startswith(\"No module named 'toolboxv2.utils\"):\n            return Result.default_internal_error(f\"404 {error_message.split('utils')[1]} not found\")\n        if error_message.startswith(\"No module named 'toolboxv2.mods\"):\n            # TODO: install from remote optional\n            return Result.default_internal_error(f\"404 {error_message.split('mods')[1]} not found\")\n        if error_message.startswith(\"No module named '\"):\n            pip_requ = error_message.split(\"'\")[1].replace(\"'\", \"\").strip()\n            # if 'y' in input(f\"\\t\\t\\tAuto install {pip_requ} Y/n\").lower:\n            return self.helper_install_pip_module(pip_requ)\n            # return Result.default_internal_error(f\"404 {pip_requ} not found\")\n\n    def inplace_load_instance(self, mod_name, loc=\"toolboxv2.mods.\", spec='app', save=True, mfo=None):\n        if self.dev_modi and loc == \"toolboxv2.mods.\":\n            loc = \"toolboxv2.mods_dev.\"\n        if self.mod_online(mod_name):\n            self.logger.info(f\"Reloading mod from : {loc + mod_name}\")\n            self.remove_mod(mod_name, spec=spec, delete=False)\n\n        if (os.path.exists(self.start_dir + '/mods/' + mod_name) or os.path.exists(\n            self.start_dir + '/mods/' + mod_name + '.py')) and (\n            os.path.isdir(self.start_dir + '/mods/' + mod_name) or os.path.isfile(\n            self.start_dir + '/mods/' + mod_name + '.py')):\n            try:\n                if mfo is None:\n                    modular_file_object = import_module(loc + mod_name)\n                else:\n                    modular_file_object = mfo\n                self.modules[mod_name] = modular_file_object\n            except ModuleNotFoundError as e:\n                self.logger.error(Style.RED(f\"module {loc + mod_name} not found is type sensitive {e}\"))\n                self.print(Style.RED(f\"module {loc + mod_name} not found is type sensitive {e}\"))\n                if self.debug or self.args_sto.sysPrint:\n                    self.python_module_import_classifier(mod_name, str(e))\n                return None\n        else:\n            self.print(f\"module {loc + mod_name} is not valid\")\n            return None\n        if hasattr(modular_file_object, \"Tools\"):\n            tools_class = getattr(modular_file_object, \"Tools\")\n        else:\n            if hasattr(modular_file_object, \"name\"):\n                tools_class = modular_file_object\n                modular_file_object = import_module(loc + mod_name)\n            else:\n                tools_class = None\n\n        modular_id = None\n        instance = modular_file_object\n        app_instance_type = \"file/application\"\n\n        if tools_class is None:\n            modular_id = getattr(modular_file_object, \"Name\")\n\n        if tools_class is None and modular_id is None:\n            modular_id = str(modular_file_object.__name__)\n            self.logger.warning(f\"Unknown instance loaded {mod_name}\")\n            return modular_file_object\n\n        if tools_class is not None:\n            tools_class = self.save_initialized_module(tools_class, spec)\n            modular_id = tools_class.name\n            app_instance_type = \"functions/class\"\n        else:\n            instance.spec = spec\n        # if private:\n        #     self.functions[modular_id][f\"{spec}_private\"] = private\n\n        if not save:\n            return instance if tools_class is None else tools_class\n\n        return self.save_instance(instance, modular_id, spec, app_instance_type, tools_class=tools_class)\n\n    def save_instance(self, instance, modular_id, spec='app', instance_type=\"file/application\", tools_class=None):\n\n        if modular_id in self.functions and tools_class is None:\n            if self.functions[modular_id].get(f\"{spec}_instance\", None) is None:\n                self.functions[modular_id][f\"{spec}_instance\"] = instance\n                self.functions[modular_id][f\"{spec}_instance_type\"] = instance_type\n            else:\n                self.print(\"ERROR OVERRIDE\")\n                raise ImportError(f\"Module already known {modular_id}\")\n\n            on_start = self.functions[modular_id].get(\"on_start\")\n            if on_start is not None:\n                i = 1\n                for f in on_start:\n                    try:\n                        f_, e = self.get_function((modular_id, f), state=True, specification=spec)\n                        if e == 0:\n                            self.logger.info(Style.GREY(f\"Running On start {f} {i}/{len(on_start)}\"))\n                            o = f_()\n                            if o is not None:\n                                self.print(f\"Function On start result: {o}\")\n                        else:\n                            self.logger.warning(f\"starting function not found {e}\")\n                    except Exception as e:\n                        self.logger.debug(Style.YELLOW(\n                            Style.Bold(f\"modular:{modular_id}.{f} on_start error {i}/{len(on_start)} -&gt; {e}\")))\n                    finally:\n                        i += 1\n\n        elif tools_class is not None:\n            if modular_id not in self.functions:\n                self.functions[modular_id] = {}\n            self.functions[modular_id][f\"{spec}_instance\"] = tools_class\n            self.functions[modular_id][f\"{spec}_instance_type\"] = instance_type\n\n            try:\n                if not hasattr(tools_class, 'tools'):\n                    tools_class.tools = {\"Version\": tools_class.get_version, 'name': tools_class.name}\n                for function_name in list(tools_class.tools.keys()):\n                    t_function_name = function_name.lower()\n                    if t_function_name != \"all\" and t_function_name != \"name\":\n                        self.tb(function_name, mod_name=modular_id)(tools_class.tools.get(function_name))\n                self.functions[modular_id][f\"{spec}_instance_type\"] += \"/BC\"\n            except Exception as e:\n                self.logger.error(f\"Starting Module {modular_id} compatibility failed with : {e}\")\n                pass\n        elif modular_id not in self.functions and tools_class is None:\n            self.functions[modular_id] = {}\n            self.functions[modular_id][f\"{spec}_instance\"] = instance\n            self.functions[modular_id][f\"{spec}_instance_type\"] = instance_type\n\n        else:\n            raise ImportError(f\"Modular {modular_id} is not a valid mod\")\n\n        return instance if tools_class is None else tools_class\n\n    def save_initialized_module(self, tools_class, spec):\n        tools_class.spec = spec\n        live_tools_class = tools_class(app=self)\n        return live_tools_class\n\n    def mod_online(self, mod_name, installed=False):\n        if installed and mod_name not in self.functions:\n            self.save_load(mod_name)\n        return mod_name in self.functions\n\n    def _get_function(self,\n                      name: Enum or None,\n                      state: bool = True,\n                      specification: str = \"app\",\n                      metadata=False, as_str: tuple or None = None, r=0):\n\n        if as_str is None and isinstance(name, Enum):\n            modular_id = str(name.NAME.value)\n            function_id = str(name.value)\n        elif as_str is None and isinstance(name, list):\n            modular_id, function_id = name[0], name[1]\n        else:\n            modular_id, function_id = as_str\n\n        self.logger.info(f\"getting function : {specification}.{modular_id}.{function_id}\")\n\n        if modular_id not in self.functions.keys():\n            if r == 0:\n                self.save_load(modular_id, spec=specification)\n                return self.get_function(name=(modular_id, function_id),\n                                         state=state,\n                                         specification=specification,\n                                         metadata=metadata,\n                                         r=1)\n            self.logger.warning(f\"function modular not found {modular_id} 404\")\n            return \"404\", 100\n\n        if function_id not in self.functions[modular_id]:\n            self.logger.warning(f\"function data not found {modular_id}.{function_id} 404\")\n            return \"404\", 404\n\n        function_data = self.functions[modular_id][function_id]\n\n        if isinstance(function_data, list):\n            print(f\"functions {function_id} : {function_data}\")\n            function_data = self.functions[modular_id][function_data[-1]]\n\n        function = function_data.get(\"func\")\n        params = function_data.get(\"params\")\n\n        state_ = function_data.get(\"state\")\n        if state_ is not None and state != state_:\n            state = state_\n\n        if function is None:\n            self.logger.warning(f\"No function found\")\n            return \"404\", 300\n\n        if params is None:\n            self.logger.warning(f\"No function (params) found\")\n            return \"404\", 301\n\n        if metadata and not state:\n            self.logger.info(f\"returning metadata stateless\")\n            return (function_data, function), 0\n\n        if not state:  # mens a stateless function\n            self.logger.info(f\"returning stateless function\")\n            return function, 0\n\n        instance = self.functions[modular_id].get(f\"{specification}_instance\")\n\n        # instance_type = self.functions[modular_id].get(f\"{specification}_instance_type\", \"functions/class\")\n\n        if params[0] == 'app':\n            instance = get_app(from_=f\"fuction {specification}.{modular_id}.{function_id}\")\n\n        if instance is None and self.alive:\n            self.inplace_load_instance(modular_id)\n            instance = self.functions[modular_id].get(f\"{specification}_instance\")\n\n        if instance is None:\n            self.logger.warning(f\"No live Instance found\")\n            return \"404\", 400\n\n        # if instance_type.endswith(\"/BC\"):  # for backwards compatibility  functions/class/BC old modules\n        #     # returning as stateless\n        #     # return \"422\", -1\n        #     self.logger.info(\n        #         f\"returning stateless function, cant find tools class for state handling found {instance_type}\")\n        #     if metadata:\n        #         self.logger.info(f\"returning metadata stateless\")\n        #         return (function_data, function), 0\n        #     return function, 0\n\n        self.logger.info(f\"wrapping in higher_order_function\")\n\n        self.logger.info(f\"returned fuction {specification}.{modular_id}.{function_id}\")\n        higher_order_function = partial(function, instance)\n\n        if metadata:\n            self.logger.info(f\"returning metadata stateful\")\n            return (function_data, higher_order_function), 0\n\n        self.logger.info(f\"returning stateful function\")\n        return higher_order_function, 0\n\n    def save_exit(self):\n        self.logger.info(f\"save exiting saving data to {self.config_fh.file_handler_filename} states of {self.debug=}\")\n        self.config_fh.add_to_save_file_handler(self.keys[\"debug\"], str(self.debug))\n\n    def load_mod(self, mod_name: str, mlm='I', **kwargs):\n\n        action_list_helper = ['I (inplace load dill on error python)',\n                              # 'C (coppy py file to runtime dir)',\n                              # 'S (save py file to dill)',\n                              # 'CS (coppy and save py file)',\n                              # 'D (development mode, inplace load py file)'\n                              ]\n        action_list = {\"I\": lambda: self.inplace_load_instance(mod_name, **kwargs),\n                       \"C\": lambda: self._copy_load(mod_name, **kwargs)\n                       }\n\n        try:\n            if mlm in action_list:\n\n                return action_list.get(mlm)()\n            else:\n                self.logger.critical(\n                    f\"config mlm must be {' or '.join(action_list_helper)} is {mlm=}\")\n                raise ValueError(f\"config mlm must be {' or '.join(action_list_helper)} is {mlm=}\")\n        except ValueError as e:\n            self.logger.warning(Style.YELLOW(f\"Error Loading Module '{mod_name}', with error :{e}\"))\n            self.debug_rains(e)\n        except ImportError as e:\n            self.logger.error(Style.YELLOW(f\"Error Loading Module '{mod_name}', with error :{e}\"))\n            self.debug_rains(e)\n        except Exception as e:\n            self.logger.critical(Style.RED(f\"Error Loading Module '{mod_name}', with critical error :{e}\"))\n            print(Style.RED(f\"Error Loading Module '{mod_name}'\"))\n            self.debug_rains(e)\n\n        return Result.default_internal_error(info=\"info's in logs.\")\n\n    async def load_all_mods_in_file(self, working_dir=\"mods\"):\n        print(f\"LOADING ALL MODS FROM FOLDER : {working_dir}\")\n        t0 = time.perf_counter()\n        # Get the list of all modules\n        module_list = self.get_all_mods(working_dir)\n        open_modules = self.functions.keys()\n        start_len = len(open_modules)\n\n        for om in open_modules:\n            if om in module_list:\n                module_list.remove(om)\n\n        tasks: set[Task] = set()\n\n        # if 'isaa' in module_list:\n        #     threading.Thread(target=self.save_load, args=(\"isaa\", 'app'), daemon=True).start()\n        #     module_list.remove('isaa')\n\n        _ = {tasks.add(asyncio.create_task(asyncio.to_thread(self.save_load, mod, 'app'))) for mod in module_list}\n        for t in asyncio.as_completed(tasks):\n            try:\n                result = await t\n                if hasattr(result, 'Name'):\n                    print('Opened :', result.Name)\n                elif hasattr(result, 'name'):\n                    print('Opened :', result.name)\n                else:\n                    print('Opened :', result)\n            except Exception as e:\n                self.logger.error(Style.RED(f\"An Error occurred while opening all modules error: {str(e)}\"))\n        opened = len(self.functions.keys()) - start_len\n\n        self.logger.info(f\"Opened {opened} modules in {time.perf_counter() - t0:.2f}s\")\n        return f\"Opened {opened} modules in {time.perf_counter() - t0:.2f}s\"\n\n    def get_all_mods(self, working_dir=\"mods\", path_to=\"./runtime\", use_wd=True):\n        self.logger.info(f\"collating all mods in working directory {working_dir}\")\n\n        pr = \"_dev\" if self.dev_modi else \"\"\n        if working_dir == \"mods\" and use_wd:\n            working_dir = f\"./mods{pr}\"\n        elif use_wd:\n            pass\n        else:\n            w_dir = self.id.replace(\".\", \"_\")\n            working_dir = f\"{path_to}/{w_dir}/mod_lib{pr}/\"\n        res = os.listdir(working_dir)\n\n        self.logger.info(f\"found : {len(res)} files\")\n\n        def do_helper(_mod):\n            if \"mainTool\" in _mod:\n                return False\n            # if not _mod.endswith(\".py\"):\n            #     return False\n            if _mod.startswith(\"__\"):\n                return False\n            if _mod.startswith(\"test_\"):\n                return False\n            return True\n\n        def r_endings(word: str):\n            if word.endswith(\".py\"):\n                return word[:-3]\n            return word\n\n        mods_list = list(map(r_endings, filter(do_helper, res)))\n\n        self.logger.info(f\"found : {len(mods_list)} Modules\")\n        return mods_list\n\n    def remove_all_modules(self, delete=False):\n        for mod in list(self.functions.keys()):\n            self.logger.info(f\"closing: {mod}\")\n            self.remove_mod(mod, delete=delete)\n\n    def remove_mod(self, mod_name, spec='app', delete=True):\n        if mod_name not in self.functions:\n            self.logger.info(f\"mod not active {mod_name}\")\n            return\n        on_exit = self.functions[mod_name].get(\"on_exit\")\n\n        def helper():\n            if f\"{spec}_instance\" in self.functions[mod_name]:\n                del self.functions[mod_name][f\"{spec}_instance\"]\n            if f\"{spec}_instance_type\" in self.functions[mod_name]:\n                del self.functions[mod_name][f\"{spec}_instance_type\"]\n\n        if on_exit is None and self.functions[mod_name].get(f\"{spec}_instance_type\", \"\").endswith(\"/BC\"):\n            instance = self.functions[mod_name].get(f\"{spec}_instance\", None)\n            if instance is not None and hasattr(instance, 'on_exit'):\n                if inspect.iscoroutinefunction(instance.on_exit):\n                    self.exit_tasks.append(instance.on_exit)\n                else:\n                    instance.on_exit()\n\n        if on_exit is None and delete:\n            self.functions[mod_name] = {}\n            del self.functions[mod_name]\n            return\n        if on_exit is None:\n            helper()\n            return\n\n        i = 1\n        for f in on_exit:\n            try:\n                f_, e = self.get_function((mod_name, f), state=True, specification=spec)\n                if e == 0:\n                    self.logger.info(Style.GREY(f\"Running On exit {f} {i}/{len(on_exit)}\"))\n                    if inspect.iscoroutinefunction(f_):\n                        self.exit_tasks.append(f_)\n                        o = None\n                    else:\n                        o = f_()\n                    if o is not None:\n                        self.print(f\"Function On Exit result: {o}\")\n                else:\n                    self.logger.warning(\"closing function not found\")\n            except Exception as e:\n                self.logger.debug(\n                    Style.YELLOW(Style.Bold(f\"modular:{mod_name}.{f} on_exit error {i}/{len(on_exit)} -&gt; {e}\")))\n            finally:\n                i += 1\n\n        helper()\n\n        if delete:\n            self.functions[mod_name] = {}\n            del self.functions[mod_name]\n\n    async def a_remove_all_modules(self, delete=False):\n        for mod in list(self.functions.keys()):\n            self.logger.info(f\"closing: {mod}\")\n            await self.a_remove_mod(mod, delete=delete)\n\n    async def a_remove_mod(self, mod_name, spec='app', delete=True):\n        if mod_name not in self.functions:\n            self.logger.info(f\"mod not active {mod_name}\")\n            return\n        on_exit = self.functions[mod_name].get(\"on_exit\")\n\n        def helper():\n            if f\"{spec}_instance\" in self.functions[mod_name]:\n                del self.functions[mod_name][f\"{spec}_instance\"]\n            if f\"{spec}_instance_type\" in self.functions[mod_name]:\n                del self.functions[mod_name][f\"{spec}_instance_type\"]\n\n        if on_exit is None and self.functions[mod_name].get(f\"{spec}_instance_type\", \"\").endswith(\"/BC\"):\n            instance = self.functions[mod_name].get(f\"{spec}_instance\", None)\n            if instance is not None and hasattr(instance, 'on_exit'):\n                if inspect.iscoroutinefunction(instance.on_exit):\n                    await instance.on_exit()\n                else:\n                    instance.on_exit()\n\n        if on_exit is None and delete:\n            self.functions[mod_name] = {}\n            del self.functions[mod_name]\n            return\n        if on_exit is None:\n            helper()\n            return\n\n        i = 1\n        for f in on_exit:\n            try:\n                f_, e = self.get_function((mod_name, f), state=True, specification=spec)\n                if e == 0:\n                    self.logger.info(Style.GREY(f\"Running On exit {f} {i}/{len(on_exit)}\"))\n                    if inspect.iscoroutinefunction(f_):\n                        o = await f_()\n                    else:\n                        o = f_()\n                    if o is not None:\n                        self.print(f\"Function On Exit result: {o}\")\n                else:\n                    self.logger.warning(\"closing function not found\")\n            except Exception as e:\n                self.logger.debug(\n                    Style.YELLOW(Style.Bold(f\"modular:{mod_name}.{f} on_exit error {i}/{len(on_exit)} -&gt; {e}\")))\n            finally:\n                i += 1\n\n        helper()\n\n        if delete:\n            self.functions[mod_name] = {}\n            del self.functions[mod_name]\n\n    def exit(self, remove_all=True):\n        if self.args_sto.debug:\n            self.hide_console()\n        self.disconnect()\n        if remove_all:\n            self.remove_all_modules()\n        self.logger.info(\"Exiting ToolBox interface\")\n        self.alive = False\n        self.called_exit = True, time.time()\n        self.save_exit()\n        try:\n            self.config_fh.save_file_handler()\n        except SystemExit:\n            print(\"If u ar testing this is fine else ...\")\n\n        if hasattr(self, 'daemon_app'):\n            import threading\n\n            for thread in threading.enumerate()[::-1]:\n                if thread.name == \"MainThread\":\n                    continue\n                try:\n                    with Spinner(f\"closing Thread {thread.name:^50}|\", symbols=\"s\", count_down=True,\n                                 time_in_s=0.751 if not self.debug else 0.6):\n                        thread.join(timeout=0.751 if not self.debug else 0.6)\n                except TimeoutError as e:\n                    self.logger.error(f\"Timeout error on exit {thread.name} {str(e)}\")\n                    print(str(e), f\"Timeout {thread.name}\")\n                except KeyboardInterrupt:\n                    print(\"Unsave Exit\")\n                    break\n        if hasattr(self, 'loop'):\n            with Spinner(f\"closing Event loop:\", symbols=\"+\"):\n                self.loop.stop()\n\n    async def a_exit(self):\n        await self.a_remove_all_modules()\n        results = await asyncio.gather(\n            *[asyncio.create_task(f()) for f in self.exit_tasks if inspect.iscoroutinefunction(f)])\n        for result in results:\n            self.print(f\"Function On Exit result: {result}\")\n        self.exit(remove_all=False)\n\n    def save_load(self, modname, spec='app'):\n        self.logger.debug(f\"Save load module {modname}\")\n        if not modname:\n            self.logger.warning(\"no filename specified\")\n            return False\n        try:\n            return self.load_mod(modname, spec=spec)\n        except ModuleNotFoundError as e:\n            self.logger.error(Style.RED(f\"Module {modname} not found\"))\n            self.debug_rains(e)\n\n        return False\n\n    def get_function(self, name: Enum or tuple, **kwargs):\n        \"\"\"\n        Kwargs for _get_function\n            metadata:: return the registered function dictionary\n                stateless: (function_data, None), 0\n                stateful: (function_data, higher_order_function), 0\n            state::boolean\n                specification::str default app\n        \"\"\"\n        if isinstance(name, tuple):\n            return self._get_function(None, as_str=name, **kwargs)\n        else:\n            return self._get_function(name, **kwargs)\n\n    async def a_run_function(self, mod_function_name: Enum or tuple,\n                             tb_run_function_with_state=True,\n                             tb_run_with_specification='app',\n                             args_=None,\n                             kwargs_=None,\n                             *args,\n                             **kwargs) -&gt; Result:\n\n        if kwargs_ is not None and not kwargs:\n            kwargs = kwargs_\n        if args_ is not None and not args:\n            args = args_\n        if isinstance(mod_function_name, tuple):\n            modular_name, function_name = mod_function_name\n        elif isinstance(mod_function_name, list):\n            modular_name, function_name = mod_function_name[0], mod_function_name[1]\n        elif isinstance(mod_function_name, Enum):\n            modular_name, function_name = mod_function_name.__class__.NAME.value, mod_function_name.value\n        else:\n            raise TypeError(\"Unknown function type\")\n\n        if not self.mod_online(modular_name, installed=True):\n            self.get_mod(modular_name)\n\n        function_data, error_code = self.get_function(mod_function_name, state=tb_run_function_with_state,\n                                                      metadata=True, specification=tb_run_with_specification)\n        self.logger.info(f\"Received fuction : {mod_function_name}, with execode: {error_code}\")\n        if error_code == 404:\n            mod = self.get_mod(modular_name)\n            if hasattr(mod, \"async_initialized\") and not mod.async_initialized:\n                await mod\n            function_data, error_code = self.get_function(mod_function_name, state=tb_run_function_with_state,\n                                                          metadata=True, specification=tb_run_with_specification)\n\n        if error_code == 404:\n            self.logger.warning(Style.RED(f\"Function Not Found\"))\n            return (Result.default_user_error(interface=self.interface_type,\n                                              exec_code=404,\n                                              info=f\"function not found function is not decorated\").\n                    set_origin(mod_function_name))\n\n        if error_code == 300:\n            return Result.default_internal_error(interface=self.interface_type,\n                                                 info=f\"module {modular_name}\"\n                                                      f\" has no state (instance)\").set_origin(mod_function_name)\n\n        if error_code != 0:\n            return Result.default_internal_error(interface=self.interface_type,\n                                                 exec_code=error_code,\n                                                 info=f\"Internal error\"\n                                                      f\" {modular_name}.\"\n                                                      f\"{function_name}\").set_origin(mod_function_name)\n\n        if not tb_run_function_with_state:\n            function_data, _ = function_data\n            function = function_data.get('func')\n        else:\n            function_data, function = function_data\n\n        if not function:\n            self.logger.warning(Style.RED(f\"Function {function_name} not found\"))\n            return Result.default_internal_error(interface=self.interface_type,\n                                                 exec_code=404,\n                                                 info=f\"function not found function\").set_origin(mod_function_name)\n\n        self.logger.info(f\"Profiling function\")\n        if inspect.iscoroutinefunction(function):\n            return await self.a_fuction_runner(function, function_data, args, kwargs)\n        else:\n            return self.fuction_runner(function, function_data, args, kwargs)\n\n    def run_function(self, mod_function_name: Enum or tuple,\n                     tb_run_function_with_state=True,\n                     tb_run_with_specification='app',\n                     args_=None,\n                     kwargs_=None,\n                     *args,\n                     **kwargs) -&gt; Result:\n\n        if kwargs_ is not None and not kwargs:\n            kwargs = kwargs_\n        if args_ is not None and not args:\n            args = args_\n        if isinstance(mod_function_name, tuple):\n            modular_name, function_name = mod_function_name\n        elif isinstance(mod_function_name, list):\n            modular_name, function_name = mod_function_name[0], mod_function_name[1]\n        elif isinstance(mod_function_name, Enum):\n            modular_name, function_name = mod_function_name.__class__.NAME.value, mod_function_name.value\n        else:\n            raise TypeError(\"Unknown function type\")\n\n        if not self.mod_online(modular_name, installed=True):\n            self.get_mod(modular_name)\n\n        function_data, error_code = self.get_function(mod_function_name, state=tb_run_function_with_state,\n                                                      metadata=True, specification=tb_run_with_specification)\n        self.logger.info(f\"Received fuction : {mod_function_name}, with execode: {error_code}\")\n        if error_code == 1 or error_code == 3 or error_code == 400:\n            self.get_mod(modular_name)\n            function_data, error_code = self.get_function(mod_function_name, state=tb_run_function_with_state,\n                                                          metadata=True, specification=tb_run_with_specification)\n\n        if error_code == 2:\n            self.logger.warning(Style.RED(f\"Function Not Found\"))\n            return (Result.default_user_error(interface=self.interface_type,\n                                              exec_code=404,\n                                              info=f\"function not found function is not decorated\").\n                    set_origin(mod_function_name))\n\n        if error_code == -1:\n            return Result.default_internal_error(interface=self.interface_type,\n                                                 info=f\"module {modular_name}\"\n                                                      f\" has no state (instance)\").set_origin(mod_function_name)\n\n        if error_code != 0:\n            return Result.default_internal_error(interface=self.interface_type,\n                                                 exec_code=error_code,\n                                                 info=f\"Internal error\"\n                                                      f\" {modular_name}.\"\n                                                      f\"{function_name}\").set_origin(mod_function_name)\n\n        if not tb_run_function_with_state:\n            function_data, _ = function_data\n            function = function_data.get('func')\n        else:\n            function_data, function = function_data\n\n        if not function:\n            self.logger.warning(Style.RED(f\"Function {function_name} not found\"))\n            return Result.default_internal_error(interface=self.interface_type,\n                                                 exec_code=404,\n                                                 info=f\"function not found function\").set_origin(mod_function_name)\n\n        self.logger.info(f\"Profiling function\")\n        if inspect.iscoroutinefunction(function):\n            raise ValueError(f\"Fuction {function_name} is Async use a_run_any\")\n        else:\n            return self.fuction_runner(function, function_data, args, kwargs)\n\n    def run_a_from_sync(self, function, *args):\n        return asyncio.ensure_future(function(*args))\n\n    def fuction_runner(self, function, function_data: dict, args: list, kwargs: dict):\n\n        parameters = function_data.get('params')\n        modular_name = function_data.get('module_name')\n        function_name = function_data.get('func_name')\n        row = function_data.get('row')\n        mod_function_name = f\"{modular_name}.{function_name}\"\n\n        if_self_state = 1 if 'self' in parameters else 0\n\n        try:\n            if len(parameters) == 0:\n                res = function()\n            elif len(parameters) == len(args) + if_self_state:\n                res = function(*args)\n            elif len(parameters) == len(kwargs.keys()) + if_self_state:\n                res = function(**kwargs)\n            else:\n                res = function(*args, **kwargs)\n            self.logger.info(f\"Execution done\")\n            if isinstance(res, Result):\n                formatted_result = res\n                if formatted_result.origin is None:\n                    formatted_result.set_origin(mod_function_name)\n            elif isinstance(res, ApiResult):\n                formatted_result = res\n                if formatted_result.origin is None:\n                    formatted_result.as_result().set_origin(mod_function_name).to_api_result()\n            elif row:\n                formatted_result = res\n            else:\n                # Wrap the result in a Result object\n                formatted_result = Result.ok(\n                    interface=self.interface_type,\n                    data_info=\"Auto generated result\",\n                    data=res,\n                    info=\"Function executed successfully\"\n                ).set_origin(mod_function_name)\n            if not row:\n                self.logger.info(\n                    f\"Function Exec code: {formatted_result.info.exec_code} Info's: {formatted_result.info.help_text}\")\n            else:\n                self.logger.info(\n                    f\"Function Exec data: {formatted_result}\")\n        except Exception as e:\n            self.logger.error(\n                Style.YELLOW(Style.Bold(\n                    f\"! Function ERROR: in {modular_name}.{function_name}\")))\n            # Wrap the exception in a Result object\n            formatted_result = Result.default_internal_error(info=str(e)).set_origin(mod_function_name)\n            # res = formatted_result\n            self.logger.error(\n                f\"Function {modular_name}.{function_name}\"\n                f\" executed wit an error {str(e)}, {type(e)}\")\n            self.debug_rains(e)\n            self.print(f\"! Function ERROR: in {modular_name}.{function_name} \")\n        else:\n            self.print_ok()\n\n            self.logger.info(\n                f\"Function {modular_name}.{function_name}\"\n                f\" executed successfully\")\n\n        return formatted_result\n\n    async def a_fuction_runner(self, function, function_data: dict, args: list, kwargs: dict):\n\n        parameters = function_data.get('params')\n        modular_name = function_data.get('module_name')\n        function_name = function_data.get('func_name')\n        row = function_data.get('row')\n        mod_function_name = f\"{modular_name}.{function_name}\"\n\n        if_self_state = 1 if 'self' in parameters else 0\n\n        try:\n            if len(parameters) == 0:\n                res = await function()\n            elif len(parameters) == len(args) + if_self_state:\n                res = await function(*args)\n            elif len(parameters) == len(kwargs.keys()) + if_self_state:\n                res = await function(**kwargs)\n            else:\n                res = await function(*args, **kwargs)\n            self.logger.info(f\"Execution done\")\n            if isinstance(res, Result):\n                formatted_result = res\n                if formatted_result.origin is None:\n                    formatted_result.set_origin(mod_function_name)\n            elif isinstance(res, ApiResult):\n                formatted_result = res\n                if formatted_result.origin is None:\n                    formatted_result.as_result().set_origin(mod_function_name).to_api_result()\n            elif row:\n                formatted_result = res\n            else:\n                # Wrap the result in a Result object\n                formatted_result = Result.ok(\n                    interface=self.interface_type,\n                    data_info=\"Auto generated result\",\n                    data=res,\n                    info=\"Function executed successfully\"\n                ).set_origin(mod_function_name)\n            if not row:\n                self.logger.info(\n                    f\"Function Exec code: {formatted_result.info.exec_code} Info's: {formatted_result.info.help_text}\")\n            else:\n                self.logger.info(\n                    f\"Function Exec data: {formatted_result}\")\n        except Exception as e:\n            self.logger.error(\n                Style.YELLOW(Style.Bold(\n                    f\"! Function ERROR: in {modular_name}.{function_name}\")))\n            # Wrap the exception in a Result object\n            formatted_result = Result.default_internal_error(info=str(e)).set_origin(mod_function_name)\n            # res = formatted_result\n            self.logger.error(\n                f\"Function {modular_name}.{function_name}\"\n                f\" executed wit an error {str(e)}, {type(e)}\")\n            self.debug_rains(e)\n\n        else:\n            self.print_ok()\n\n            self.logger.info(\n                f\"Function {modular_name}.{function_name}\"\n                f\" executed successfully\")\n\n        return formatted_result\n\n    async def run_http(self, mod_function_name: Enum or str or tuple, function_name=None,\n                       args_=None,\n                       kwargs_=None, method=\"GET\",\n                       *args, **kwargs):\n        if kwargs_ is not None and not kwargs:\n            kwargs = kwargs_\n        if args_ is not None and not args:\n            args = args_\n\n        modular_name = mod_function_name\n        function_name = function_name\n\n        if isinstance(mod_function_name, str) and isinstance(function_name, str):\n            mod_function_name = (mod_function_name, function_name)\n\n        if isinstance(mod_function_name, tuple):\n            modular_name, function_name = mod_function_name\n        elif isinstance(mod_function_name, list):\n            modular_name, function_name = mod_function_name[0], mod_function_name[1]\n        elif isinstance(mod_function_name, Enum):\n            modular_name, function_name = mod_function_name.__class__.NAME.value, mod_function_name.value\n\n\n        r = await self.session.fetch(f\"/api/{modular_name}/{function_name}{'?' + args_ if args_ is not None else ''}\",\n                                     data=kwargs, method=method)\n        return await r.json()\n\n    def run_local(self, *args, **kwargs):\n        return self.run_any(*args, **kwargs)\n\n    async def a_run_local(self, *args, **kwargs):\n        return await self.a_run_any(*args, **kwargs)\n\n    def run_any(self, mod_function_name: Enum or str or tuple, backwords_compability_variabel_string_holder=None,\n                get_results=False, tb_run_function_with_state=True, tb_run_with_specification='app', args_=None,\n                kwargs_=None,\n                *args, **kwargs):\n\n        # if self.debug:\n        #     self.logger.info(f'Called from: {getouterframes(currentframe(), 2)}')\n\n        if kwargs_ is not None and not kwargs:\n            kwargs = kwargs_\n        if args_ is not None and not args:\n            args = args_\n\n        if isinstance(mod_function_name, str) and isinstance(backwords_compability_variabel_string_holder, str):\n            mod_function_name = (mod_function_name, backwords_compability_variabel_string_holder)\n\n        res: Result = self.run_function(mod_function_name,\n                                        tb_run_function_with_state=tb_run_function_with_state,\n                                        tb_run_with_specification=tb_run_with_specification,\n                                        args_=args, kwargs_=kwargs).as_result()\n        if self.debug:\n            res.log(show_data=False)\n        if not get_results and isinstance(res, Result):\n            return res.get()\n\n        return res\n\n    async def a_run_any(self, mod_function_name: Enum or str or tuple,\n                        backwords_compability_variabel_string_holder=None,\n                        get_results=False, tb_run_function_with_state=True, tb_run_with_specification='app', args_=None,\n                        kwargs_=None,\n                        *args, **kwargs):\n\n        # if self.debug:\n        #     self.logger.info(f'Called from: {getouterframes(currentframe(), 2)}')\n\n        if kwargs_ is not None and not kwargs:\n            kwargs = kwargs_\n        if args_ is not None and not args:\n            args = args_\n\n        if isinstance(mod_function_name, str) and isinstance(backwords_compability_variabel_string_holder, str):\n            mod_function_name = (mod_function_name, backwords_compability_variabel_string_holder)\n\n        res: Result = await self.a_run_function(mod_function_name,\n                                                tb_run_function_with_state=tb_run_function_with_state,\n                                                tb_run_with_specification=tb_run_with_specification,\n                                                args_=args, kwargs_=kwargs)\n\n        if isinstance(res, ApiResult):\n            res = res.as_result()\n\n        if self.debug:\n            res.log(show_data=False)\n        if not get_results and isinstance(res, Result):\n            return res.get()\n\n        return res\n\n    def get_mod(self, name, spec='app') -&gt; ModuleType or MainToolType:\n        if name not in self.functions.keys():\n            mod = self.save_load(name, spec=spec)\n            if mod is False or (isinstance(mod, Result) and mod.is_error()):\n                self.logger.warning(f\"Could not find {name} in {list(self.functions.keys())}\")\n                raise ValueError(f\"Could not find {name} in {list(self.functions.keys())} pleas install the module\")\n        # private = self.functions[name].get(f\"{spec}_private\")\n        # if private is not None:\n        #     if private and spec != 'app':\n        #         raise ValueError(\"Module is private\")\n        if name not in self.functions:\n            self.logger.warning(f\"Module '{name}' is not found\")\n            return None\n        instance = self.functions[name].get(f\"{spec}_instance\")\n        if instance is None:\n            return self.load_mod(name, spec=spec)\n        return self.functions[name].get(f\"{spec}_instance\")\n\n    def print(self, text, *args, **kwargs):\n        # self.logger.info(f\"Output : {text}\")\n        if self.sprint(None):\n            print(Style.CYAN(f\"System${self.id}:\"), end=\" \")\n        print(text, *args, **kwargs)\n\n    def sprint(self, text, *args, **kwargs):\n        if text is None:\n            return True\n        # self.logger.info(f\"Output : {text}\")\n        print(Style.CYAN(f\"System${self.id}:\"), end=\" \")\n        if isinstance(text, str) and kwargs == {} and text:\n            stram_print(text + ' '.join(args))\n            print()\n        else:\n            print(text, *args, **kwargs)\n\n    # ----------------------------------------------------------------\n    # Decorators for the toolbox\n\n    def reload_mod(self, mod_name, spec='app', is_file=True, loc=\"toolboxv2.mods.\"):\n        if not is_file:\n            mods = self.get_all_mods(\"./mods/\" + mod_name)\n            for mod in mods:\n                try:\n                    reload(import_module(loc + mod_name + '.' + mod))\n                    self.print(f\"Reloaded {mod_name}.{mod}\")\n                except ImportError:\n                    self.print(f\"Could not load {mod_name}.{mod}\")\n        self.inplace_load_instance(mod_name, spec=spec, mfo=reload(self.modules[mod_name]))\n\n    def watch_mod(self, mod_name, spec='app', loc=\"toolboxv2.mods.\", use_thread=True, path_name=None):\n        if path_name is None:\n            path_name = mod_name\n        is_file = os.path.isfile(self.start_dir + '/mods/' + path_name + '.py')\n        import watchfiles\n        def helper():\n            paths = f'mods/{path_name}' + ('.py' if is_file else '')\n            self.print(f'Watching Path: {paths}')\n            for changes in watchfiles.watch(paths):\n                print(changes)\n                self.reload_mod(mod_name, spec, is_file, loc)\n\n        if not use_thread:\n            helper()\n        else:\n            threading.Thread(target=helper, daemon=True).start()\n\n    def _register_function(self, module_name, func_name, data):\n        if module_name not in self.functions:\n            self.functions[module_name] = {}\n        if func_name in self.functions[module_name]:\n            self.print(f\"Overriding function {func_name} from {module_name}\")\n            self.functions[module_name][func_name] = data\n        else:\n            self.functions[module_name][func_name] = data\n\n    def _create_decorator(self, type_: str,\n                          name: str = \"\",\n                          mod_name: str = \"\",\n                          level: int = -1,\n                          restrict_in_virtual_mode: bool = False,\n                          api: bool = False,\n                          helper: str = \"\",\n                          version: str or None = None,\n                          initial=False,\n                          exit_f=False,\n                          test=True,\n                          samples=None,\n                          state=None,\n                          pre_compute=None,\n                          post_compute=None,\n                          api_methods=None,\n                          memory_cache=False,\n                          file_cache=False,\n                          request_as_kwarg=False,\n                          row=False,\n                          memory_cache_max_size=100,\n                          memory_cache_ttl=300):\n\n        if isinstance(type_, Enum):\n            type_ = type_.value\n\n        if memory_cache and file_cache:\n            raise ValueError(\"Don't use both cash at the same time for the same fuction\")\n\n        use_cache = memory_cache or file_cache\n        cache = {}\n        if file_cache:\n            cache = FileCache(folder=self.data_dir + f'\\\\cache\\\\{mod_name}\\\\',\n                              filename=self.data_dir + f'\\\\cache\\\\{mod_name}\\\\{name}cache.db')\n        if memory_cache:\n            cache = MemoryCache(maxsize=memory_cache_max_size, ttl=memory_cache_ttl)\n\n        version = self.version if version is None else self.version + ':' + version\n\n        def a_additional_process(func):\n\n            async def executor(*args, **kwargs):\n\n                if pre_compute is not None:\n                    args, kwargs = await pre_compute(*args, **kwargs)\n                if inspect.iscoroutinefunction(func):\n                    result = await func(*args, **kwargs)\n                else:\n                    result = func(*args, **kwargs)\n                if post_compute is not None:\n                    result = await post_compute(result)\n                if row:\n                    return result\n                if not isinstance(result, Result):\n                    result = Result.ok(data=result)\n                if result.origin is None:\n                    result.set_origin((mod_name if mod_name else func.__module__.split('.')[-1]\n                                       , name if name else func.__name__\n                                       , type_))\n                if result.result.data_to == ToolBoxInterfaces.native.name:\n                    result.result.data_to = ToolBoxInterfaces.remote if api else ToolBoxInterfaces.native\n                # Wenden Sie die to_api_result Methode auf das Ergebnis an, falls verf\u00fcgbar\n                if api and hasattr(result, 'to_api_result'):\n                    return result.to_api_result()\n                return result\n\n            @wraps(func)\n            async def wrapper(*args, **kwargs):\n\n                if not use_cache:\n                    return await executor(*args, **kwargs)\n\n                try:\n                    cache_key = (f\"{mod_name if mod_name else func.__module__.split('.')[-1]}\"\n                                 f\"-{func.__name__}-{str(args)},{str(kwargs.items())}\")\n                except ValueError:\n                    cache_key = (f\"{mod_name if mod_name else func.__module__.split('.')[-1]}\"\n                                 f\"-{func.__name__}-{bytes(args)},{str(kwargs.items())}\")\n\n                result = cache.get(cache_key)\n                if result is not None:\n                    return result\n\n                result = await executor(*args, **kwargs)\n\n                cache.set(cache_key, result)\n\n                return result\n\n            return wrapper\n\n        def additional_process(func):\n\n            def executor(*args, **kwargs):\n\n                if pre_compute is not None:\n                    args, kwargs = pre_compute(*args, **kwargs)\n                if inspect.iscoroutinefunction(func):\n                    result = func(*args, **kwargs)\n                else:\n                    result = func(*args, **kwargs)\n                if post_compute is not None:\n                    result = post_compute(result)\n                if row:\n                    return result\n                if not isinstance(result, Result):\n                    result = Result.ok(data=result)\n                if result.origin is None:\n                    result.set_origin((mod_name if mod_name else func.__module__.split('.')[-1]\n                                       , name if name else func.__name__\n                                       , type_))\n                if result.result.data_to == ToolBoxInterfaces.native.name:\n                    result.result.data_to = ToolBoxInterfaces.remote if api else ToolBoxInterfaces.native\n                # Wenden Sie die to_api_result Methode auf das Ergebnis an, falls verf\u00fcgbar\n                if api and hasattr(result, 'to_api_result'):\n                    return result.to_api_result()\n                return result\n\n            @wraps(func)\n            def wrapper(*args, **kwargs):\n\n                if not use_cache:\n                    return executor(*args, **kwargs)\n\n                try:\n                    cache_key = (f\"{mod_name if mod_name else func.__module__.split('.')[-1]}\"\n                                 f\"-{func.__name__}-{str(args)},{str(kwargs.items())}\")\n                except ValueError:\n                    cache_key = (f\"{mod_name if mod_name else func.__module__.split('.')[-1]}\"\n                                 f\"-{func.__name__}-{bytes(args)},{str(kwargs.items())}\")\n\n                result = cache.get(cache_key)\n                if result is not None:\n                    return result\n\n                result = executor(*args, **kwargs)\n\n                cache.set(cache_key, result)\n\n                return result\n\n            return wrapper\n\n        def decorator(func):\n            sig = signature(func)\n            params = list(sig.parameters)\n            module_name = mod_name if mod_name else func.__module__.split('.')[-1]\n            func_name = name if name else func.__name__\n            if func_name == 'on_start':\n                func_name = 'on_startup'\n            if func_name == 'on_exit':\n                func_name = 'on_close'\n            if api or pre_compute is not None or post_compute is not None or memory_cache or file_cache:\n                if inspect.iscoroutinefunction(func):\n                    func = a_additional_process(func)\n                else:\n                    func = additional_process(func)\n            if api and 'Result' == str(sig.return_annotation):\n                raise ValueError(f\"Fuction {module_name}.{func_name} registered as \"\n                                 f\"Api fuction but uses {str(sig.return_annotation)}\\n\"\n                                 f\"Please change the sig from ..)-&gt; Result to ..)-&gt; ApiResult\")\n            data = {\n                \"type\": type_,\n                \"module_name\": module_name,\n                \"func_name\": func_name,\n                \"level\": level,\n                \"restrict_in_virtual_mode\": restrict_in_virtual_mode,\n                \"func\": func,\n                \"api\": api,\n                \"helper\": helper,\n                \"version\": version,\n                \"initial\": initial,\n                \"exit_f\": exit_f,\n                \"api_methods\": api_methods if api_methods is not None else [\"AUTO\"],\n                \"__module__\": func.__module__,\n                \"signature\": sig,\n                \"params\": params,\n                \"row\": row,\n                \"state\": (\n                    False if len(params) == 0 else params[0] in ['self', 'state', 'app']) if state is None else state,\n                \"do_test\": test,\n                \"samples\": samples,\n                \"request_as_kwarg\": request_as_kwarg,\n\n            }\n            self._register_function(module_name, func_name, data)\n            if exit_f:\n                if \"on_exit\" not in self.functions[module_name]:\n                    self.functions[module_name][\"on_exit\"] = []\n                self.functions[module_name][\"on_exit\"].append(func_name)\n            if initial:\n                if \"on_start\" not in self.functions[module_name]:\n                    self.functions[module_name][\"on_start\"] = []\n                self.functions[module_name][\"on_start\"].append(func_name)\n\n            return func\n\n        decorator.tb_init = True\n\n        return decorator\n\n    def tb(self, name=None,\n           mod_name: str = \"\",\n           helper: str = \"\",\n           version: str or None = None,\n           test: bool = True,\n           restrict_in_virtual_mode: bool = False,\n           api: bool = False,\n           initial: bool = False,\n           exit_f: bool = False,\n           test_only: bool = False,\n           memory_cache: bool = False,\n           file_cache: bool = False,\n           request_as_kwarg: bool = False,\n           row: bool = False,\n           state: bool or None = None,\n           level: int = -1,\n           memory_cache_max_size: int = 100,\n           memory_cache_ttl: int = 300,\n           samples: list or dict or None = None,\n           interface: ToolBoxInterfaces or None or str = None,\n           pre_compute=None,\n           post_compute=None,\n           api_methods=None,\n           ):\n        \"\"\"\n    A decorator for registering and configuring functions within a module.\n\n    This decorator is used to wrap functions with additional functionality such as caching, API conversion, and lifecycle management (initialization and exit). It also handles the registration of the function in the module's function registry.\n\n    Args:\n        name (str, optional): The name to register the function under. Defaults to the function's own name.\n        mod_name (str, optional): The name of the module the function belongs to.\n        helper (str, optional): A helper string providing additional information about the function.\n        version (str or None, optional): The version of the function or module.\n        test (bool, optional): Flag to indicate if the function is for testing purposes.\n        restrict_in_virtual_mode (bool, optional): Flag to restrict the function in virtual mode.\n        api (bool, optional): Flag to indicate if the function is part of an API.\n        initial (bool, optional): Flag to indicate if the function should be executed at initialization.\n        exit_f (bool, optional): Flag to indicate if the function should be executed at exit.\n        test_only (bool, optional): Flag to indicate if the function should only be used for testing.\n        memory_cache (bool, optional): Flag to enable memory caching for the function.\n        request_as_kwarg (bool, optional): Flag to get request if the fuction is calld from api.\n        file_cache (bool, optional): Flag to enable file caching for the function.\n        row (bool, optional): rather to auto wrap the result in Result type default False means no row data aka result type\n        state (bool or None, optional): Flag to indicate if the function maintains state.\n        level (int, optional): The level of the function, used for prioritization or categorization.\n        memory_cache_max_size (int, optional): Maximum size of the memory cache.\n        memory_cache_ttl (int, optional): Time-to-live for the memory cache entries.\n        samples (list or dict or None, optional): Samples or examples of function usage.\n        interface (str, optional): The interface type for the function.\n        pre_compute (callable, optional): A function to be called before the main function.\n        post_compute (callable, optional): A function to be called after the main function.\n        api_methods (list[str], optional): default [\"AUTO\"] (GET if not params, POST if params) , GET, POST, PUT or DELETE.\n\n    Returns:\n        function: The decorated function with additional processing and registration capabilities.\n    \"\"\"\n        if interface is None:\n            interface = \"tb\"\n        if test_only and 'test' not in self.id:\n            return lambda *args, **kwargs: args\n        return self._create_decorator(interface,\n                                      name,\n                                      mod_name,\n                                      level=level,\n                                      restrict_in_virtual_mode=restrict_in_virtual_mode,\n                                      helper=helper,\n                                      api=api,\n                                      version=version,\n                                      initial=initial,\n                                      exit_f=exit_f,\n                                      test=test,\n                                      samples=samples,\n                                      state=state,\n                                      pre_compute=pre_compute,\n                                      post_compute=post_compute,\n                                      memory_cache=memory_cache,\n                                      file_cache=file_cache,\n                                      request_as_kwarg=request_as_kwarg,\n                                      row=row,\n                                      api_methods=api_methods,\n                                      memory_cache_max_size=memory_cache_max_size,\n                                      memory_cache_ttl=memory_cache_ttl)\n\n    def save_autocompletion_dict(self):\n        autocompletion_dict = {}\n        for module_name, module in self.functions.items():\n            data = {}\n            for function_name, function_data in self.functions[module_name].items():\n                if not isinstance(function_data, dict):\n                    continue\n                data[function_name] = {arg: None for arg in\n                                       function_data.get(\"params\", [])}  # TODO get default from sig\n                if len(data[function_name].keys()) == 0:\n                    data[function_name] = None\n            autocompletion_dict[module_name] = data if len(data.keys()) &gt; 0 else None\n        self.config_fh.add_to_save_file_handler(\"auto~~~~~~\", str(autocompletion_dict))\n\n    def get_autocompletion_dict(self):\n        return self.config_fh.get_file_handler(\"auto~~~~~~\")\n\n    def save_registry_as_enums(self, directory: str, filename: str):\n        # Ordner erstellen, falls nicht vorhanden\n        if not os.path.exists(directory):\n            os.makedirs(directory)\n\n        # Dateipfad vorbereiten\n        filepath = os.path.join(directory, filename)\n\n        # Enum-Klassen als Strings generieren\n        enum_classes = [f'\"\"\"Automatic generated by ToolBox v = {self.version}\"\"\"'\n                        f'\\nfrom enum import Enum\\nfrom dataclasses import dataclass'\n                        f'\\n\\n\\n']\n        for module, functions in self.functions.items():\n            if module.startswith(\"APP_INSTANCE\"):\n                continue\n            class_name = module\n            enum_members = \"\\n    \".join(\n                [\n                    f\"{func_name.upper().replace('-', '')}:\"\n                    f\" str = '{func_name}'  \"\n                    f\"# Input: ({fuction_data['params'] if isinstance(fuction_data, dict) else ''}),\"\n                    f\" Output: {fuction_data['signature'].return_annotation if isinstance(fuction_data, dict) else 'None'}\"\n                    for func_name, fuction_data in functions.items()])\n            enum_class = (f'@dataclass\\nclass {class_name.upper().replace(\".\", \"_\").replace(\"-\", \"\")}(Enum):'\n                          f\"\\n    NAME = '{class_name}'\\n    {enum_members}\")\n            enum_classes.append(enum_class)\n\n        # Enums in die Datei schreiben\n        data = \"\\n\\n\\n\".join(enum_classes)\n        if len(data) &lt; 12:\n            raise ValueError(\n                \"Invalid Enums Loosing content pleas delete it ur self in the (utils/system/all_functions_enums.py) or add mor new stuff :}\")\n        with open(filepath, 'w') as file:\n            file.write(data)\n\n        print(Style.Bold(Style.BLUE(f\"Enums gespeichert in {filepath}\")))\n</code></pre> Source code in <code>toolboxv2/utils/system/main_tool.py</code> <pre><code>class MainTool:\n    toolID: str = \"\"\n    # app = None\n    interface = None\n    spec = \"app\"\n    name = \"\"\n    color = \"Bold\"\n    stuf = False\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Standard constructor used for arguments pass\n        Do not override. Use __ainit__ instead\n        \"\"\"\n        self.__storedargs = args, kwargs\n        self.async_initialized = False\n\n    async def __ainit__(self, *args, **kwargs):\n        self.version = kwargs[\"v\"]\n        self.tools = kwargs.get(\"tool\", {})\n        self.name = kwargs[\"name\"]\n        self.logger = kwargs.get(\"logs\", get_logger())\n        self.color = kwargs.get(\"color\", \"WHITE\")\n        self.todo = kwargs.get(\"load\", lambda: None)\n        if not hasattr(self, 'config'):\n            self.config = {}\n        self.user = None\n        self.description = \"A toolbox mod\" if kwargs.get(\"description\") is None else kwargs.get(\"description\")\n        if MainTool.interface is None:\n            MainTool.interface = self.app.interface_type\n        # Result.default(self.app.interface)\n        if self.todo:\n            try:\n                if inspect.iscoroutinefunction(self.todo):\n                    await self.todo()\n                else:\n                    self.todo()\n                await asyncio.sleep(0)\n            except Exception as e:\n                get_logger().error(f\" Error loading mod {self.name} {e}\")\n        else:\n            get_logger().info(f\"{self.name} no load require\")\n\n        self.app.print(f\"TOOL : {self.spec}.{self.name} online\")\n\n    @property\n    def app(self):\n        return get_app(\n            from_=f\"{self.spec}.{self.name}|{self.toolID if self.toolID else '*' + MainTool.toolID} {self.interface if self.interface else MainTool.interface}\")\n\n    @app.setter\n    def app(self, v):\n        raise PermissionError(f\"You cannot set the App Instance! {v=}\")\n\n    @staticmethod\n    def return_result(error: ToolBoxError = ToolBoxError.none,\n                      exec_code: int = 0,\n                      help_text: str = \"\",\n                      data_info=None,\n                      data=None,\n                      data_to=None):\n\n        if data_to is None:\n            data_to = MainTool.interface if MainTool.interface is not None else ToolBoxInterfaces.cli\n\n        if data is None:\n            data = {}\n\n        if data_info is None:\n            data_info = {}\n\n        return Result(\n            error,\n            ToolBoxResult(data_info=data_info, data=data, data_to=data_to),\n            ToolBoxInfo(exec_code=exec_code, help_text=help_text)\n        )\n\n    def print(self, message, end=\"\\n\", **kwargs):\n        if self.stuf:\n            return\n\n        self.app.print(Style.style_dic[self.color] + self.name + Style.style_dic[\"END\"] + \":\", message, end=end,\n                       **kwargs)\n\n    def add_str_to_config(self, command):\n        if len(command) != 2:\n            self.logger.error('Invalid command must be key value')\n            return False\n        self.config[command[0]] = command[1]\n\n    def webInstall(self, user_instance, construct_render) -&gt; str:\n        \"\"\"\"Returns a web installer for the given user instance and construct render template\"\"\"\n\n    def get_version(self) -&gt; str:\n        \"\"\"\"Returns the version\"\"\"\n        return self.version\n\n    async def get_user(self, username: str) -&gt; Result:\n        return await self.app.a_run_any(CLOUDM_AUTHMANAGER.GET_USER_BY_NAME, username=username, get_results=True)\n\n    async def __initobj(self):\n        \"\"\"Crutch used for __await__ after spawning\"\"\"\n        assert not self.async_initialized\n        self.async_initialized = True\n        # pass the parameters to __ainit__ that passed to __init__\n        await self.__ainit__(*self.__storedargs[0], **self.__storedargs[1])\n        return self\n\n    def __await__(self):\n        return self.__initobj().__await__()\n</code></pre> Source code in <code>toolboxv2/utils/system/file_handler.py</code> <pre><code>class FileHandler(Code):\n\n    def __init__(self, filename, name='mainTool', keys=None, defaults=None):\n        if defaults is None:\n            defaults = {}\n        if keys is None:\n            keys = {}\n        assert filename.endswith(\".config\") or filename.endswith(\".data\"), \\\n            f\"filename must end with .config or .data {filename=}\"\n        self.file_handler_save = {}\n        self.file_handler_load = {}\n        self.file_handler_key_mapper = {}\n        self.file_handler_filename = filename\n        self.file_handler_storage = None\n        self.file_handler_max_loaded_index_ = 0\n        self.file_handler_file_prefix = (f\".{filename.split('.')[1]}/\"\n                                         f\"{name.replace('.', '-')}/\")\n        # self.load_file_handler()\n        self.set_defaults_keys_file_handler(keys, defaults)\n\n    def _open_file_handler(self, mode: str, rdu):\n        logger = get_logger()\n        logger.info(Style.Bold(Style.YELLOW(f\"Opening file in mode : {mode}\")))\n        if self.file_handler_storage:\n            self.file_handler_storage.close()\n            self.file_handler_storage = None\n        try:\n            self.file_handler_storage = open(self.file_handler_file_prefix + self.file_handler_filename, mode)\n            self.file_handler_max_loaded_index_ += 1\n        except FileNotFoundError:\n            if self.file_handler_max_loaded_index_ == 2:\n                os.makedirs(self.file_handler_file_prefix, exist_ok=True)\n            if self.file_handler_max_loaded_index_ == 3:\n                os.makedirs(\".config/mainTool\", exist_ok=True)\n            if self.file_handler_max_loaded_index_ &gt;= 5:\n                print(Style.RED(f\"pleas create this file to prosed : {self.file_handler_file_prefix}\"\n                                f\"{self.file_handler_filename}\"))\n                logger.critical(f\"{self.file_handler_file_prefix} {self.file_handler_filename} FileNotFoundError cannot\"\n                                f\" be Created\")\n                exit(0)\n            self.file_handler_max_loaded_index_ += 1\n            logger.info(Style.YELLOW(f\"Try Creating File: {self.file_handler_file_prefix}{self.file_handler_filename}\"))\n\n            if not os.path.exists(f\"{self.file_handler_file_prefix}\"):\n                os.makedirs(f\"{self.file_handler_file_prefix}\")\n\n            with open(self.file_handler_file_prefix + self.file_handler_filename, 'a'):\n                logger.info(Style.GREEN(\"File created successfully\"))\n                self.file_handler_max_loaded_index_ = -1\n            rdu()\n        except OSError and PermissionError as e:\n            raise e\n\n    def open_s_file_handler(self):\n        self._open_file_handler('w+', self.open_s_file_handler)\n        return self\n\n    def open_l_file_handler(self):\n        self._open_file_handler('r+', self.open_l_file_handler)\n        return self\n\n    def save_file_handler(self):\n        get_logger().info(\n            Style.BLUE(\n                f\"init Saving (S) {self.file_handler_filename} \"\n            )\n        )\n        if self.file_handler_storage:\n            get_logger().warning(\n                f\"WARNING file is already open (S): {self.file_handler_filename} {self.file_handler_storage}\")\n\n        self.open_s_file_handler()\n\n        get_logger().info(\n            Style.BLUE(\n                f\"Elements to save : ({len(self.file_handler_save.keys())})\"\n            )\n        )\n\n        self.file_handler_storage.write(json.dumps(self.file_handler_save))\n\n        self.file_handler_storage.close()\n        self.file_handler_storage = None\n\n        get_logger().info(\n            Style.BLUE(\n                f\"closing file : {self.file_handler_filename} \"\n            )\n        )\n\n        return self\n\n    def add_to_save_file_handler(self, key: str, value: str):\n        if len(key) != 10:\n            get_logger(). \\\n                warning(\n                Style.YELLOW(\n                    'WARNING: key length is not 10 characters'\n                )\n            )\n            return False\n        if key not in self.file_handler_load.keys():\n            if key in self.file_handler_key_mapper:\n                key = self.file_handler_key_mapper[key]\n\n        self.file_handler_load[key] = value\n        self.file_handler_save[key] = self.encode_code(value)\n        return True\n\n    def remove_key_file_handler(self, key: str):\n        if key == 'Pka7237327':\n            print(\"Cant remove Root Key\")\n            return\n        if key in self.file_handler_load.keys():\n            del self.file_handler_load[key]\n        if key in self.file_handler_save.keys():\n            del self.file_handler_save[key]\n\n    def load_file_handler(self):\n        get_logger().info(\n            Style.BLUE(\n                f\"loading {self.file_handler_filename} \"\n            )\n        )\n        if self.file_handler_storage:\n            get_logger().warning(\n                Style.YELLOW(\n                    f\"WARNING file is already open (L) {self.file_handler_filename}\"\n                )\n            )\n        self.open_l_file_handler()\n\n        try:\n\n            self.file_handler_save = json.load(self.file_handler_storage)\n            for key, line in self.file_handler_save.items():\n                self.file_handler_load[key] = self.decode_code(line)\n\n        except json.decoder.JSONDecodeError and Exception:\n\n            for line in self.file_handler_storage:\n                line = line[:-1]\n                heda = line[:10]\n                self.file_handler_save[heda] = line[10:]\n                enc = self.decode_code(line[10:])\n                self.file_handler_load[heda] = enc\n\n            self.file_handler_save = {}\n\n        self.file_handler_storage.close()\n        self.file_handler_storage = None\n\n        return self\n\n    def get_file_handler(self, obj: str, default=None) -&gt; str or None:\n        logger = get_logger()\n        if obj not in self.file_handler_load.keys():\n            if obj in self.file_handler_key_mapper:\n                obj = self.file_handler_key_mapper[obj]\n        logger.info(Style.ITALIC(Style.GREY(f\"Collecting data from storage key : {obj}\")))\n        self.file_handler_max_loaded_index_ = -1\n        for objects in self.file_handler_load.items():\n            self.file_handler_max_loaded_index_ += 1\n            if obj == objects[0]:\n\n                try:\n                    if len(objects[1]) &gt; 0:\n                        return eval(objects[1]) if isinstance(objects[1], str) else objects[1]\n                    logger.warning(\n                        Style.YELLOW(\n                            f\"No data  {obj}  ; {self.file_handler_filename}\"\n                        )\n                    )\n                except ValueError:\n                    logger.error(f\"ValueError Loading {obj} ; {self.file_handler_filename}\")\n                except SyntaxError:\n                    if isinstance(objects[1], str):\n                        return objects[1]\n                    logger.warning(\n                        Style.YELLOW(\n                            f\"Possible SyntaxError Loading {obj} ; {self.file_handler_filename}\"\n                            f\" {len(objects[1])} {type(objects[1])}\"\n                        )\n                    )\n                    return objects[1]\n                    # print(Style.YELLOW(f\"Data frc : {obj} ; {objects[1]}\"))\n                except NameError:\n                    return str(objects[1])\n\n        if obj in list(self.file_handler_save.keys()):\n            r = self.decode_code(self.file_handler_save[obj])\n            logger.info(f\"returning Default for {obj}\")\n            return r\n\n        logger.info(f\"no data found\")\n        return default\n\n    def set_defaults_keys_file_handler(self, keys: dict, defaults: dict):\n        list_keys = iter(list(keys.keys()))\n        df_keys = defaults.keys()\n        for key in list_keys:\n            self.file_handler_key_mapper[key] = keys[key]\n            self.file_handler_key_mapper[keys[key]] = key\n            if key in df_keys:\n                self.file_handler_load[keys[key]] = str(defaults[key])\n                self.file_handler_save[keys[key]] = self.encode_code(defaults[key])\n            else:\n                self.file_handler_load[keys[key]] = \"None\"\n\n    def delete_file(self):\n        os.remove(self.file_handler_file_prefix + self.file_handler_filename)\n        get_logger().warning(Style.GREEN(f\"File deleted {self.file_handler_file_prefix + self.file_handler_filename}\"))\n</code></pre> Source code in <code>toolboxv2/utils/extras/Style.py</code> <pre><code>class Style:\n    _END = '\\33[0m'\n    _BLACK = '\\33[30m'\n    _RED = '\\33[31m'\n    _GREEN = '\\33[32m'\n    _YELLOW = '\\33[33m'\n    _BLUE = '\\33[34m'\n    _MAGENTA = '\\33[35m'\n    _CYAN = '\\33[36m'\n    _WHITE = '\\33[37m'\n\n    _Bold = '\\33[1m'\n    _ITALIC = '\\33[3m'\n    _Underline = '\\33[4m'\n    _BLINK = '\\33[5m'\n    _BLINK2 = '\\33[6m'\n    _Reversed = '\\33[7m'\n\n    _BLACKBG = '\\33[40m'\n    _REDBG = '\\33[41m'\n    _GREENBG = '\\33[42m'\n    _YELLOWBG = '\\33[43m'\n    _BLUEBG = '\\33[44m'\n    _VIOLETBG = '\\33[45m'\n    _BEIGEBG = '\\33[46m'\n    _WHITEBG = '\\33[47m'\n\n    _GREY = '\\33[90m'\n    _RED2 = '\\33[91m'\n    _GREEN2 = '\\33[92m'\n    _YELLOW2 = '\\33[93m'\n    _BLUE2 = '\\33[94m'\n    _VIOLET2 = '\\33[95m'\n    _BEIGE2 = '\\33[96m'\n    _WHITE2 = '\\33[97m'\n\n    _GREYBG = '\\33[100m'\n    _REDBG2 = '\\33[101m'\n    _GREENBG2 = '\\33[102m'\n    _YELLOWBG2 = '\\33[103m'\n    _BLUEBG2 = '\\33[104m'\n    _VIOLETBG2 = '\\33[105m'\n    _BEIGEBG2 = '\\33[106m'\n    _WHITEBG2 = '\\33[107m'\n\n    style_dic = {\n        \"END\": _END,\n        \"BLACK\": _BLACK,\n        \"RED\": _RED,\n        \"GREEN\": _GREEN,\n        \"YELLOW\": _YELLOW,\n        \"BLUE\": _BLUE,\n        \"MAGENTA\": _MAGENTA,\n        \"CYAN\": _CYAN,\n        \"WHITE\": _WHITE,\n        \"Bold\": _Bold,\n        \"Underline\": _Underline,\n        \"Reversed\": _Reversed,\n\n        \"ITALIC\": _ITALIC,\n        \"BLINK\": _BLINK,\n        \"BLINK2\": _BLINK2,\n        \"BLACKBG\": _BLACKBG,\n        \"REDBG\": _REDBG,\n        \"GREENBG\": _GREENBG,\n        \"YELLOWBG\": _YELLOWBG,\n        \"BLUEBG\": _BLUEBG,\n        \"VIOLETBG\": _VIOLETBG,\n        \"BEIGEBG\": _BEIGEBG,\n        \"WHITEBG\": _WHITEBG,\n        \"GREY\": _GREY,\n        \"RED2\": _RED2,\n        \"GREEN2\": _GREEN2,\n        \"YELLOW2\": _YELLOW2,\n        \"BLUE2\": _BLUE2,\n        \"VIOLET2\": _VIOLET2,\n        \"BEIGE2\": _BEIGE2,\n        \"WHITE2\": _WHITE2,\n        \"GREYBG\": _GREYBG,\n        \"REDBG2\": _REDBG2,\n        \"GREENBG2\": _GREENBG2,\n        \"YELLOWBG2\": _YELLOWBG2,\n        \"BLUEBG2\": _BLUEBG2,\n        \"VIOLETBG2\": _VIOLETBG2,\n        \"BEIGEBG2\": _BEIGEBG2,\n        \"WHITEBG2\": _WHITEBG2,\n\n    }\n\n    @staticmethod\n    def END_():\n        print(Style._END)\n\n    @staticmethod\n    def GREEN_():\n        print(Style._GREEN)\n\n    @staticmethod\n    def BLUE(text: str):\n        return Style._BLUE + text + Style._END\n\n    @staticmethod\n    def BLACK(text: str):\n        return Style._BLACK + text + Style._END\n\n    @staticmethod\n    def RED(text: str):\n        return Style._RED + text + Style._END\n\n    @staticmethod\n    def GREEN(text: str):\n        return Style._GREEN + text + Style._END\n\n    @staticmethod\n    def YELLOW(text: str):\n        return Style._YELLOW + text + Style._END\n\n    @staticmethod\n    def MAGENTA(text: str):\n        return Style._MAGENTA + text + Style._END\n\n    @staticmethod\n    def CYAN(text: str):\n        return Style._CYAN + text + Style._END\n\n    @staticmethod\n    def WHITE(text: str):\n        return Style._WHITE + text + Style._END\n\n    @staticmethod\n    def Bold(text: str):\n        return Style._Bold + text + Style._END\n\n    @staticmethod\n    def Underline(text: str):\n        return Style._Underline + text + Style._END\n\n    @staticmethod\n    def Reversed(text: str):\n        return Style._Reversed + text + Style._END\n\n    @staticmethod\n    def ITALIC(text: str):\n        return Style._ITALIC + text + Style._END\n\n    @staticmethod\n    def BLINK(text: str):\n        return Style._BLINK + text + Style._END\n\n    @staticmethod\n    def BLINK2(text: str):\n        return Style._BLINK2 + text + Style._END\n\n    @staticmethod\n    def BLACKBG(text: str):\n        return Style._BLACKBG + text + Style._END\n\n    @staticmethod\n    def REDBG(text: str):\n        return Style._REDBG + text + Style._END\n\n    @staticmethod\n    def GREENBG(text: str):\n        return Style._GREENBG + text + Style._END\n\n    @staticmethod\n    def YELLOWBG(text: str):\n        return Style._YELLOWBG + text + Style._END\n\n    @staticmethod\n    def BLUEBG(text: str):\n        return Style._BLUEBG + text + Style._END\n\n    @staticmethod\n    def VIOLETBG(text: str):\n        return Style._VIOLETBG + text + Style._END\n\n    @staticmethod\n    def BEIGEBG(text: str):\n        return Style._BEIGEBG + text + Style._END\n\n    @staticmethod\n    def WHITEBG(text: str):\n        return Style._WHITEBG + text + Style._END\n\n    @staticmethod\n    def GREY(text: str):\n        return Style._GREY + text + Style._END\n\n    @staticmethod\n    def RED2(text: str):\n        return Style._RED2 + text + Style._END\n\n    @staticmethod\n    def GREEN2(text: str):\n        return Style._GREEN2 + text + Style._END\n\n    @staticmethod\n    def YELLOW2(text: str):\n        return Style._YELLOW2 + text + Style._END\n\n    @staticmethod\n    def BLUE2(text: str):\n        return Style._BLUE2 + text + Style._END\n\n    @staticmethod\n    def VIOLET2(text: str):\n        return Style._VIOLET2 + text + Style._END\n\n    @staticmethod\n    def BEIGE2(text: str):\n        return Style._BEIGE2 + text + Style._END\n\n    @staticmethod\n    def WHITE2(text: str):\n        return Style._WHITE2 + text + Style._END\n\n    @staticmethod\n    def GREYBG(text: str):\n        return Style._GREYBG + text + Style._END\n\n    @staticmethod\n    def REDBG2(text: str):\n        return Style._REDBG2 + text + Style._END\n\n    @staticmethod\n    def GREENBG2(text: str):\n        return Style._GREENBG2 + text + Style._END\n\n    @staticmethod\n    def YELLOWBG2(text: str):\n        return Style._YELLOWBG2 + text + Style._END\n\n    @staticmethod\n    def BLUEBG2(text: str):\n        return Style._BLUEBG2 + text + Style._END\n\n    @staticmethod\n    def VIOLETBG2(text: str):\n        return Style._VIOLETBG2 + text + Style._END\n\n    @staticmethod\n    def BEIGEBG2(text: str):\n        return Style._BEIGEBG2 + text + Style._END\n\n    @staticmethod\n    def WHITEBG2(text: str):\n        return Style._WHITEBG2 + text + Style._END\n\n    @staticmethod\n    def loading_al(text: str):\n        b = f\"{text} /\"\n        print(b)\n        sleep(0.05)\n        cls()\n        b = f\"{text} -\"\n        print(b)\n        sleep(0.05)\n        cls()\n        b = f\"{text} \\\\\"\n        print(b)\n        sleep(0.05)\n        cls()\n        b = f\"{text} |\"\n        print(b)\n        sleep(0.05)\n        cls()\n\n    @property\n    def END(self):\n        return self._END\n\n    def color_demo(self):\n        for color in self.style_dic.keys():\n            print(f\"{color} -&gt; {self.style_dic[color]}Effect{self._END}\")\n\n    @property\n    def Underline2(self):\n        return self._Underline\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.debug","title":"<code>debug</code>  <code>property</code> <code>writable</code>","text":"<p>proxi attr</p>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.a_exit","title":"<code>a_exit(self)</code>  <code>async</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>async def a_exit(self):\n    await self.a_remove_all_modules()\n    results = await asyncio.gather(\n        *[asyncio.create_task(f()) for f in self.exit_tasks if inspect.iscoroutinefunction(f)])\n    for result in results:\n        self.print(f\"Function On Exit result: {result}\")\n    self.exit(remove_all=False)\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.a_fuction_runner","title":"<code>a_fuction_runner(self, function, function_data, args, kwargs)</code>  <code>async</code>","text":"<p>parameters = function_data.get('params') modular_name = function_data.get('module_name') function_name = function_data.get('func_name') mod_function_name = f\"{modular_name}.{function_name}\"</p> <p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>async def a_fuction_runner(self, function, function_data: dict, args: list, kwargs: dict):\n\n    parameters = function_data.get('params')\n    modular_name = function_data.get('module_name')\n    function_name = function_data.get('func_name')\n    row = function_data.get('row')\n    mod_function_name = f\"{modular_name}.{function_name}\"\n\n    if_self_state = 1 if 'self' in parameters else 0\n\n    try:\n        if len(parameters) == 0:\n            res = await function()\n        elif len(parameters) == len(args) + if_self_state:\n            res = await function(*args)\n        elif len(parameters) == len(kwargs.keys()) + if_self_state:\n            res = await function(**kwargs)\n        else:\n            res = await function(*args, **kwargs)\n        self.logger.info(f\"Execution done\")\n        if isinstance(res, Result):\n            formatted_result = res\n            if formatted_result.origin is None:\n                formatted_result.set_origin(mod_function_name)\n        elif isinstance(res, ApiResult):\n            formatted_result = res\n            if formatted_result.origin is None:\n                formatted_result.as_result().set_origin(mod_function_name).to_api_result()\n        elif row:\n            formatted_result = res\n        else:\n            # Wrap the result in a Result object\n            formatted_result = Result.ok(\n                interface=self.interface_type,\n                data_info=\"Auto generated result\",\n                data=res,\n                info=\"Function executed successfully\"\n            ).set_origin(mod_function_name)\n        if not row:\n            self.logger.info(\n                f\"Function Exec code: {formatted_result.info.exec_code} Info's: {formatted_result.info.help_text}\")\n        else:\n            self.logger.info(\n                f\"Function Exec data: {formatted_result}\")\n    except Exception as e:\n        self.logger.error(\n            Style.YELLOW(Style.Bold(\n                f\"! Function ERROR: in {modular_name}.{function_name}\")))\n        # Wrap the exception in a Result object\n        formatted_result = Result.default_internal_error(info=str(e)).set_origin(mod_function_name)\n        # res = formatted_result\n        self.logger.error(\n            f\"Function {modular_name}.{function_name}\"\n            f\" executed wit an error {str(e)}, {type(e)}\")\n        self.debug_rains(e)\n\n    else:\n        self.print_ok()\n\n        self.logger.info(\n            f\"Function {modular_name}.{function_name}\"\n            f\" executed successfully\")\n\n    return formatted_result\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.a_remove_mod","title":"<code>a_remove_mod(self, mod_name, spec='app', delete=True)</code>  <code>async</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>async def a_remove_mod(self, mod_name, spec='app', delete=True):\n    if mod_name not in self.functions:\n        self.logger.info(f\"mod not active {mod_name}\")\n        return\n    on_exit = self.functions[mod_name].get(\"on_exit\")\n\n    def helper():\n        if f\"{spec}_instance\" in self.functions[mod_name]:\n            del self.functions[mod_name][f\"{spec}_instance\"]\n        if f\"{spec}_instance_type\" in self.functions[mod_name]:\n            del self.functions[mod_name][f\"{spec}_instance_type\"]\n\n    if on_exit is None and self.functions[mod_name].get(f\"{spec}_instance_type\", \"\").endswith(\"/BC\"):\n        instance = self.functions[mod_name].get(f\"{spec}_instance\", None)\n        if instance is not None and hasattr(instance, 'on_exit'):\n            if inspect.iscoroutinefunction(instance.on_exit):\n                await instance.on_exit()\n            else:\n                instance.on_exit()\n\n    if on_exit is None and delete:\n        self.functions[mod_name] = {}\n        del self.functions[mod_name]\n        return\n    if on_exit is None:\n        helper()\n        return\n\n    i = 1\n    for f in on_exit:\n        try:\n            f_, e = self.get_function((mod_name, f), state=True, specification=spec)\n            if e == 0:\n                self.logger.info(Style.GREY(f\"Running On exit {f} {i}/{len(on_exit)}\"))\n                if inspect.iscoroutinefunction(f_):\n                    o = await f_()\n                else:\n                    o = f_()\n                if o is not None:\n                    self.print(f\"Function On Exit result: {o}\")\n            else:\n                self.logger.warning(\"closing function not found\")\n        except Exception as e:\n            self.logger.debug(\n                Style.YELLOW(Style.Bold(f\"modular:{mod_name}.{f} on_exit error {i}/{len(on_exit)} -&gt; {e}\")))\n        finally:\n            i += 1\n\n    helper()\n\n    if delete:\n        self.functions[mod_name] = {}\n        del self.functions[mod_name]\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.a_run_any","title":"<code>a_run_any(self, mod_function_name, backwords_compability_variabel_string_holder=None, get_results=False, tb_run_function_with_state=True, tb_run_with_specification='app', args_=None, kwargs_=None, *args, **kwargs)</code>  <code>async</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>async def a_run_any(self, mod_function_name: Enum or str or tuple,\n                    backwords_compability_variabel_string_holder=None,\n                    get_results=False, tb_run_function_with_state=True, tb_run_with_specification='app', args_=None,\n                    kwargs_=None,\n                    *args, **kwargs):\n\n    # if self.debug:\n    #     self.logger.info(f'Called from: {getouterframes(currentframe(), 2)}')\n\n    if kwargs_ is not None and not kwargs:\n        kwargs = kwargs_\n    if args_ is not None and not args:\n        args = args_\n\n    if isinstance(mod_function_name, str) and isinstance(backwords_compability_variabel_string_holder, str):\n        mod_function_name = (mod_function_name, backwords_compability_variabel_string_holder)\n\n    res: Result = await self.a_run_function(mod_function_name,\n                                            tb_run_function_with_state=tb_run_function_with_state,\n                                            tb_run_with_specification=tb_run_with_specification,\n                                            args_=args, kwargs_=kwargs)\n\n    if isinstance(res, ApiResult):\n        res = res.as_result()\n\n    if self.debug:\n        res.log(show_data=False)\n    if not get_results and isinstance(res, Result):\n        return res.get()\n\n    return res\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.a_run_function","title":"<code>a_run_function(self, mod_function_name, tb_run_function_with_state=True, tb_run_with_specification='app', args_=None, kwargs_=None, *args, **kwargs)</code>  <code>async</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>async def a_run_function(self, mod_function_name: Enum or tuple,\n                         tb_run_function_with_state=True,\n                         tb_run_with_specification='app',\n                         args_=None,\n                         kwargs_=None,\n                         *args,\n                         **kwargs) -&gt; Result:\n\n    if kwargs_ is not None and not kwargs:\n        kwargs = kwargs_\n    if args_ is not None and not args:\n        args = args_\n    if isinstance(mod_function_name, tuple):\n        modular_name, function_name = mod_function_name\n    elif isinstance(mod_function_name, list):\n        modular_name, function_name = mod_function_name[0], mod_function_name[1]\n    elif isinstance(mod_function_name, Enum):\n        modular_name, function_name = mod_function_name.__class__.NAME.value, mod_function_name.value\n    else:\n        raise TypeError(\"Unknown function type\")\n\n    if not self.mod_online(modular_name, installed=True):\n        self.get_mod(modular_name)\n\n    function_data, error_code = self.get_function(mod_function_name, state=tb_run_function_with_state,\n                                                  metadata=True, specification=tb_run_with_specification)\n    self.logger.info(f\"Received fuction : {mod_function_name}, with execode: {error_code}\")\n    if error_code == 404:\n        mod = self.get_mod(modular_name)\n        if hasattr(mod, \"async_initialized\") and not mod.async_initialized:\n            await mod\n        function_data, error_code = self.get_function(mod_function_name, state=tb_run_function_with_state,\n                                                      metadata=True, specification=tb_run_with_specification)\n\n    if error_code == 404:\n        self.logger.warning(Style.RED(f\"Function Not Found\"))\n        return (Result.default_user_error(interface=self.interface_type,\n                                          exec_code=404,\n                                          info=f\"function not found function is not decorated\").\n                set_origin(mod_function_name))\n\n    if error_code == 300:\n        return Result.default_internal_error(interface=self.interface_type,\n                                             info=f\"module {modular_name}\"\n                                                  f\" has no state (instance)\").set_origin(mod_function_name)\n\n    if error_code != 0:\n        return Result.default_internal_error(interface=self.interface_type,\n                                             exec_code=error_code,\n                                             info=f\"Internal error\"\n                                                  f\" {modular_name}.\"\n                                                  f\"{function_name}\").set_origin(mod_function_name)\n\n    if not tb_run_function_with_state:\n        function_data, _ = function_data\n        function = function_data.get('func')\n    else:\n        function_data, function = function_data\n\n    if not function:\n        self.logger.warning(Style.RED(f\"Function {function_name} not found\"))\n        return Result.default_internal_error(interface=self.interface_type,\n                                             exec_code=404,\n                                             info=f\"function not found function\").set_origin(mod_function_name)\n\n    self.logger.info(f\"Profiling function\")\n    if inspect.iscoroutinefunction(function):\n        return await self.a_fuction_runner(function, function_data, args, kwargs)\n    else:\n        return self.fuction_runner(function, function_data, args, kwargs)\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.debug_rains","title":"<code>debug_rains(self, e)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def debug_rains(self, e):\n    if self.debug:\n        raise e\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.disconnect","title":"<code>disconnect(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>@staticmethod\ndef disconnect(*args, **kwargs):\n    \"\"\"proxi attr\"\"\"\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.exit","title":"<code>exit(self, remove_all=True)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def exit(self, remove_all=True):\n    if self.args_sto.debug:\n        self.hide_console()\n    self.disconnect()\n    if remove_all:\n        self.remove_all_modules()\n    self.logger.info(\"Exiting ToolBox interface\")\n    self.alive = False\n    self.called_exit = True, time.time()\n    self.save_exit()\n    try:\n        self.config_fh.save_file_handler()\n    except SystemExit:\n        print(\"If u ar testing this is fine else ...\")\n\n    if hasattr(self, 'daemon_app'):\n        import threading\n\n        for thread in threading.enumerate()[::-1]:\n            if thread.name == \"MainThread\":\n                continue\n            try:\n                with Spinner(f\"closing Thread {thread.name:^50}|\", symbols=\"s\", count_down=True,\n                             time_in_s=0.751 if not self.debug else 0.6):\n                    thread.join(timeout=0.751 if not self.debug else 0.6)\n            except TimeoutError as e:\n                self.logger.error(f\"Timeout error on exit {thread.name} {str(e)}\")\n                print(str(e), f\"Timeout {thread.name}\")\n            except KeyboardInterrupt:\n                print(\"Unsave Exit\")\n                break\n    if hasattr(self, 'loop'):\n        with Spinner(f\"closing Event loop:\", symbols=\"+\"):\n            self.loop.stop()\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.exit_main","title":"<code>exit_main(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>@staticmethod\ndef exit_main(*args, **kwargs):\n    \"\"\"proxi attr\"\"\"\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.fuction_runner","title":"<code>fuction_runner(self, function, function_data, args, kwargs)</code>","text":"<p>parameters = function_data.get('params') modular_name = function_data.get('module_name') function_name = function_data.get('func_name') mod_function_name = f\"{modular_name}.{function_name}\"</p> <p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def fuction_runner(self, function, function_data: dict, args: list, kwargs: dict):\n\n    parameters = function_data.get('params')\n    modular_name = function_data.get('module_name')\n    function_name = function_data.get('func_name')\n    row = function_data.get('row')\n    mod_function_name = f\"{modular_name}.{function_name}\"\n\n    if_self_state = 1 if 'self' in parameters else 0\n\n    try:\n        if len(parameters) == 0:\n            res = function()\n        elif len(parameters) == len(args) + if_self_state:\n            res = function(*args)\n        elif len(parameters) == len(kwargs.keys()) + if_self_state:\n            res = function(**kwargs)\n        else:\n            res = function(*args, **kwargs)\n        self.logger.info(f\"Execution done\")\n        if isinstance(res, Result):\n            formatted_result = res\n            if formatted_result.origin is None:\n                formatted_result.set_origin(mod_function_name)\n        elif isinstance(res, ApiResult):\n            formatted_result = res\n            if formatted_result.origin is None:\n                formatted_result.as_result().set_origin(mod_function_name).to_api_result()\n        elif row:\n            formatted_result = res\n        else:\n            # Wrap the result in a Result object\n            formatted_result = Result.ok(\n                interface=self.interface_type,\n                data_info=\"Auto generated result\",\n                data=res,\n                info=\"Function executed successfully\"\n            ).set_origin(mod_function_name)\n        if not row:\n            self.logger.info(\n                f\"Function Exec code: {formatted_result.info.exec_code} Info's: {formatted_result.info.help_text}\")\n        else:\n            self.logger.info(\n                f\"Function Exec data: {formatted_result}\")\n    except Exception as e:\n        self.logger.error(\n            Style.YELLOW(Style.Bold(\n                f\"! Function ERROR: in {modular_name}.{function_name}\")))\n        # Wrap the exception in a Result object\n        formatted_result = Result.default_internal_error(info=str(e)).set_origin(mod_function_name)\n        # res = formatted_result\n        self.logger.error(\n            f\"Function {modular_name}.{function_name}\"\n            f\" executed wit an error {str(e)}, {type(e)}\")\n        self.debug_rains(e)\n        self.print(f\"! Function ERROR: in {modular_name}.{function_name} \")\n    else:\n        self.print_ok()\n\n        self.logger.info(\n            f\"Function {modular_name}.{function_name}\"\n            f\" executed successfully\")\n\n    return formatted_result\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.get_all_mods","title":"<code>get_all_mods(self, working_dir='mods', path_to='./runtime', use_wd=True)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def get_all_mods(self, working_dir=\"mods\", path_to=\"./runtime\", use_wd=True):\n    self.logger.info(f\"collating all mods in working directory {working_dir}\")\n\n    pr = \"_dev\" if self.dev_modi else \"\"\n    if working_dir == \"mods\" and use_wd:\n        working_dir = f\"./mods{pr}\"\n    elif use_wd:\n        pass\n    else:\n        w_dir = self.id.replace(\".\", \"_\")\n        working_dir = f\"{path_to}/{w_dir}/mod_lib{pr}/\"\n    res = os.listdir(working_dir)\n\n    self.logger.info(f\"found : {len(res)} files\")\n\n    def do_helper(_mod):\n        if \"mainTool\" in _mod:\n            return False\n        # if not _mod.endswith(\".py\"):\n        #     return False\n        if _mod.startswith(\"__\"):\n            return False\n        if _mod.startswith(\"test_\"):\n            return False\n        return True\n\n    def r_endings(word: str):\n        if word.endswith(\".py\"):\n            return word[:-3]\n        return word\n\n    mods_list = list(map(r_endings, filter(do_helper, res)))\n\n    self.logger.info(f\"found : {len(mods_list)} Modules\")\n    return mods_list\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.get_autocompletion_dict","title":"<code>get_autocompletion_dict(self)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def get_autocompletion_dict(self):\n    return self.config_fh.get_file_handler(\"auto~~~~~~\")\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.get_function","title":"<code>get_function(self, name, **kwargs)</code>","text":"<p>Kwargs for _get_function     metadata:: return the registered function dictionary         stateless: (function_data, None), 0         stateful: (function_data, higher_order_function), 0     state::boolean         specification::str default app</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def get_function(self, name: Enum or tuple, **kwargs):\n    \"\"\"\n    Kwargs for _get_function\n        metadata:: return the registered function dictionary\n            stateless: (function_data, None), 0\n            stateful: (function_data, higher_order_function), 0\n        state::boolean\n            specification::str default app\n    \"\"\"\n    if isinstance(name, tuple):\n        return self._get_function(None, as_str=name, **kwargs)\n    else:\n        return self._get_function(name, **kwargs)\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.get_mod","title":"<code>get_mod(self, name, spec='app')</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def get_mod(self, name, spec='app') -&gt; ModuleType or MainToolType:\n    if name not in self.functions.keys():\n        mod = self.save_load(name, spec=spec)\n        if mod is False or (isinstance(mod, Result) and mod.is_error()):\n            self.logger.warning(f\"Could not find {name} in {list(self.functions.keys())}\")\n            raise ValueError(f\"Could not find {name} in {list(self.functions.keys())} pleas install the module\")\n    # private = self.functions[name].get(f\"{spec}_private\")\n    # if private is not None:\n    #     if private and spec != 'app':\n    #         raise ValueError(\"Module is private\")\n    if name not in self.functions:\n        self.logger.warning(f\"Module '{name}' is not found\")\n        return None\n    instance = self.functions[name].get(f\"{spec}_instance\")\n    if instance is None:\n        return self.load_mod(name, spec=spec)\n    return self.functions[name].get(f\"{spec}_instance\")\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.get_username","title":"<code>get_username(self, get_input=False)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def get_username(self, get_input=False):\n    user_name = self.config_fh.get_file_handler(\"ac_user:::\")\n    if get_input and user_name is None and user_name != \"None\":\n        user_name = input(\"Input your username\\nbe sure to make no typos: \")\n        self.config_fh.add_to_save_file_handler(\"ac_user:::\", user_name)\n    if user_name is None:\n        user_name = ''\n    return user_name\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.hide_console","title":"<code>hide_console(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>@staticmethod\ndef hide_console(*args, **kwargs):\n    \"\"\"proxi attr\"\"\"\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.inplace_load_instance","title":"<code>inplace_load_instance(self, mod_name, loc='toolboxv2.mods.', spec='app', save=True, mfo=None)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def inplace_load_instance(self, mod_name, loc=\"toolboxv2.mods.\", spec='app', save=True, mfo=None):\n    if self.dev_modi and loc == \"toolboxv2.mods.\":\n        loc = \"toolboxv2.mods_dev.\"\n    if self.mod_online(mod_name):\n        self.logger.info(f\"Reloading mod from : {loc + mod_name}\")\n        self.remove_mod(mod_name, spec=spec, delete=False)\n\n    if (os.path.exists(self.start_dir + '/mods/' + mod_name) or os.path.exists(\n        self.start_dir + '/mods/' + mod_name + '.py')) and (\n        os.path.isdir(self.start_dir + '/mods/' + mod_name) or os.path.isfile(\n        self.start_dir + '/mods/' + mod_name + '.py')):\n        try:\n            if mfo is None:\n                modular_file_object = import_module(loc + mod_name)\n            else:\n                modular_file_object = mfo\n            self.modules[mod_name] = modular_file_object\n        except ModuleNotFoundError as e:\n            self.logger.error(Style.RED(f\"module {loc + mod_name} not found is type sensitive {e}\"))\n            self.print(Style.RED(f\"module {loc + mod_name} not found is type sensitive {e}\"))\n            if self.debug or self.args_sto.sysPrint:\n                self.python_module_import_classifier(mod_name, str(e))\n            return None\n    else:\n        self.print(f\"module {loc + mod_name} is not valid\")\n        return None\n    if hasattr(modular_file_object, \"Tools\"):\n        tools_class = getattr(modular_file_object, \"Tools\")\n    else:\n        if hasattr(modular_file_object, \"name\"):\n            tools_class = modular_file_object\n            modular_file_object = import_module(loc + mod_name)\n        else:\n            tools_class = None\n\n    modular_id = None\n    instance = modular_file_object\n    app_instance_type = \"file/application\"\n\n    if tools_class is None:\n        modular_id = getattr(modular_file_object, \"Name\")\n\n    if tools_class is None and modular_id is None:\n        modular_id = str(modular_file_object.__name__)\n        self.logger.warning(f\"Unknown instance loaded {mod_name}\")\n        return modular_file_object\n\n    if tools_class is not None:\n        tools_class = self.save_initialized_module(tools_class, spec)\n        modular_id = tools_class.name\n        app_instance_type = \"functions/class\"\n    else:\n        instance.spec = spec\n    # if private:\n    #     self.functions[modular_id][f\"{spec}_private\"] = private\n\n    if not save:\n        return instance if tools_class is None else tools_class\n\n    return self.save_instance(instance, modular_id, spec, app_instance_type, tools_class=tools_class)\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.load_all_mods_in_file","title":"<code>load_all_mods_in_file(self, working_dir='mods')</code>  <code>async</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>async def load_all_mods_in_file(self, working_dir=\"mods\"):\n    print(f\"LOADING ALL MODS FROM FOLDER : {working_dir}\")\n    t0 = time.perf_counter()\n    # Get the list of all modules\n    module_list = self.get_all_mods(working_dir)\n    open_modules = self.functions.keys()\n    start_len = len(open_modules)\n\n    for om in open_modules:\n        if om in module_list:\n            module_list.remove(om)\n\n    tasks: set[Task] = set()\n\n    # if 'isaa' in module_list:\n    #     threading.Thread(target=self.save_load, args=(\"isaa\", 'app'), daemon=True).start()\n    #     module_list.remove('isaa')\n\n    _ = {tasks.add(asyncio.create_task(asyncio.to_thread(self.save_load, mod, 'app'))) for mod in module_list}\n    for t in asyncio.as_completed(tasks):\n        try:\n            result = await t\n            if hasattr(result, 'Name'):\n                print('Opened :', result.Name)\n            elif hasattr(result, 'name'):\n                print('Opened :', result.name)\n            else:\n                print('Opened :', result)\n        except Exception as e:\n            self.logger.error(Style.RED(f\"An Error occurred while opening all modules error: {str(e)}\"))\n    opened = len(self.functions.keys()) - start_len\n\n    self.logger.info(f\"Opened {opened} modules in {time.perf_counter() - t0:.2f}s\")\n    return f\"Opened {opened} modules in {time.perf_counter() - t0:.2f}s\"\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.load_mod","title":"<code>load_mod(self, mod_name, mlm='I', **kwargs)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def load_mod(self, mod_name: str, mlm='I', **kwargs):\n\n    action_list_helper = ['I (inplace load dill on error python)',\n                          # 'C (coppy py file to runtime dir)',\n                          # 'S (save py file to dill)',\n                          # 'CS (coppy and save py file)',\n                          # 'D (development mode, inplace load py file)'\n                          ]\n    action_list = {\"I\": lambda: self.inplace_load_instance(mod_name, **kwargs),\n                   \"C\": lambda: self._copy_load(mod_name, **kwargs)\n                   }\n\n    try:\n        if mlm in action_list:\n\n            return action_list.get(mlm)()\n        else:\n            self.logger.critical(\n                f\"config mlm must be {' or '.join(action_list_helper)} is {mlm=}\")\n            raise ValueError(f\"config mlm must be {' or '.join(action_list_helper)} is {mlm=}\")\n    except ValueError as e:\n        self.logger.warning(Style.YELLOW(f\"Error Loading Module '{mod_name}', with error :{e}\"))\n        self.debug_rains(e)\n    except ImportError as e:\n        self.logger.error(Style.YELLOW(f\"Error Loading Module '{mod_name}', with error :{e}\"))\n        self.debug_rains(e)\n    except Exception as e:\n        self.logger.critical(Style.RED(f\"Error Loading Module '{mod_name}', with critical error :{e}\"))\n        print(Style.RED(f\"Error Loading Module '{mod_name}'\"))\n        self.debug_rains(e)\n\n    return Result.default_internal_error(info=\"info's in logs.\")\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.mod_online","title":"<code>mod_online(self, mod_name, installed=False)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def mod_online(self, mod_name, installed=False):\n    if installed and mod_name not in self.functions:\n        self.save_load(mod_name)\n    return mod_name in self.functions\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.print","title":"<code>print(self, text, *args, **kwargs)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def print(self, text, *args, **kwargs):\n    # self.logger.info(f\"Output : {text}\")\n    if self.sprint(None):\n        print(Style.CYAN(f\"System${self.id}:\"), end=\" \")\n    print(text, *args, **kwargs)\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.reload_mod","title":"<code>reload_mod(self, mod_name, spec='app', is_file=True, loc='toolboxv2.mods.')</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def reload_mod(self, mod_name, spec='app', is_file=True, loc=\"toolboxv2.mods.\"):\n    if not is_file:\n        mods = self.get_all_mods(\"./mods/\" + mod_name)\n        for mod in mods:\n            try:\n                reload(import_module(loc + mod_name + '.' + mod))\n                self.print(f\"Reloaded {mod_name}.{mod}\")\n            except ImportError:\n                self.print(f\"Could not load {mod_name}.{mod}\")\n    self.inplace_load_instance(mod_name, spec=spec, mfo=reload(self.modules[mod_name]))\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.remove_mod","title":"<code>remove_mod(self, mod_name, spec='app', delete=True)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def remove_mod(self, mod_name, spec='app', delete=True):\n    if mod_name not in self.functions:\n        self.logger.info(f\"mod not active {mod_name}\")\n        return\n    on_exit = self.functions[mod_name].get(\"on_exit\")\n\n    def helper():\n        if f\"{spec}_instance\" in self.functions[mod_name]:\n            del self.functions[mod_name][f\"{spec}_instance\"]\n        if f\"{spec}_instance_type\" in self.functions[mod_name]:\n            del self.functions[mod_name][f\"{spec}_instance_type\"]\n\n    if on_exit is None and self.functions[mod_name].get(f\"{spec}_instance_type\", \"\").endswith(\"/BC\"):\n        instance = self.functions[mod_name].get(f\"{spec}_instance\", None)\n        if instance is not None and hasattr(instance, 'on_exit'):\n            if inspect.iscoroutinefunction(instance.on_exit):\n                self.exit_tasks.append(instance.on_exit)\n            else:\n                instance.on_exit()\n\n    if on_exit is None and delete:\n        self.functions[mod_name] = {}\n        del self.functions[mod_name]\n        return\n    if on_exit is None:\n        helper()\n        return\n\n    i = 1\n    for f in on_exit:\n        try:\n            f_, e = self.get_function((mod_name, f), state=True, specification=spec)\n            if e == 0:\n                self.logger.info(Style.GREY(f\"Running On exit {f} {i}/{len(on_exit)}\"))\n                if inspect.iscoroutinefunction(f_):\n                    self.exit_tasks.append(f_)\n                    o = None\n                else:\n                    o = f_()\n                if o is not None:\n                    self.print(f\"Function On Exit result: {o}\")\n            else:\n                self.logger.warning(\"closing function not found\")\n        except Exception as e:\n            self.logger.debug(\n                Style.YELLOW(Style.Bold(f\"modular:{mod_name}.{f} on_exit error {i}/{len(on_exit)} -&gt; {e}\")))\n        finally:\n            i += 1\n\n    helper()\n\n    if delete:\n        self.functions[mod_name] = {}\n        del self.functions[mod_name]\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.run_a_from_sync","title":"<code>run_a_from_sync(self, function, *args)</code>","text":"<p>run a async fuction</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def run_a_from_sync(self, function, *args):\n    return asyncio.ensure_future(function(*args))\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.run_any","title":"<code>run_any(self, mod_function_name, backwords_compability_variabel_string_holder=None, get_results=False, tb_run_function_with_state=True, tb_run_with_specification='app', args_=None, kwargs_=None, *args, **kwargs)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def run_any(self, mod_function_name: Enum or str or tuple, backwords_compability_variabel_string_holder=None,\n            get_results=False, tb_run_function_with_state=True, tb_run_with_specification='app', args_=None,\n            kwargs_=None,\n            *args, **kwargs):\n\n    # if self.debug:\n    #     self.logger.info(f'Called from: {getouterframes(currentframe(), 2)}')\n\n    if kwargs_ is not None and not kwargs:\n        kwargs = kwargs_\n    if args_ is not None and not args:\n        args = args_\n\n    if isinstance(mod_function_name, str) and isinstance(backwords_compability_variabel_string_holder, str):\n        mod_function_name = (mod_function_name, backwords_compability_variabel_string_holder)\n\n    res: Result = self.run_function(mod_function_name,\n                                    tb_run_function_with_state=tb_run_function_with_state,\n                                    tb_run_with_specification=tb_run_with_specification,\n                                    args_=args, kwargs_=kwargs).as_result()\n    if self.debug:\n        res.log(show_data=False)\n    if not get_results and isinstance(res, Result):\n        return res.get()\n\n    return res\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.run_function","title":"<code>run_function(self, mod_function_name, tb_run_function_with_state=True, tb_run_with_specification='app', args_=None, kwargs_=None, *args, **kwargs)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def run_function(self, mod_function_name: Enum or tuple,\n                 tb_run_function_with_state=True,\n                 tb_run_with_specification='app',\n                 args_=None,\n                 kwargs_=None,\n                 *args,\n                 **kwargs) -&gt; Result:\n\n    if kwargs_ is not None and not kwargs:\n        kwargs = kwargs_\n    if args_ is not None and not args:\n        args = args_\n    if isinstance(mod_function_name, tuple):\n        modular_name, function_name = mod_function_name\n    elif isinstance(mod_function_name, list):\n        modular_name, function_name = mod_function_name[0], mod_function_name[1]\n    elif isinstance(mod_function_name, Enum):\n        modular_name, function_name = mod_function_name.__class__.NAME.value, mod_function_name.value\n    else:\n        raise TypeError(\"Unknown function type\")\n\n    if not self.mod_online(modular_name, installed=True):\n        self.get_mod(modular_name)\n\n    function_data, error_code = self.get_function(mod_function_name, state=tb_run_function_with_state,\n                                                  metadata=True, specification=tb_run_with_specification)\n    self.logger.info(f\"Received fuction : {mod_function_name}, with execode: {error_code}\")\n    if error_code == 1 or error_code == 3 or error_code == 400:\n        self.get_mod(modular_name)\n        function_data, error_code = self.get_function(mod_function_name, state=tb_run_function_with_state,\n                                                      metadata=True, specification=tb_run_with_specification)\n\n    if error_code == 2:\n        self.logger.warning(Style.RED(f\"Function Not Found\"))\n        return (Result.default_user_error(interface=self.interface_type,\n                                          exec_code=404,\n                                          info=f\"function not found function is not decorated\").\n                set_origin(mod_function_name))\n\n    if error_code == -1:\n        return Result.default_internal_error(interface=self.interface_type,\n                                             info=f\"module {modular_name}\"\n                                                  f\" has no state (instance)\").set_origin(mod_function_name)\n\n    if error_code != 0:\n        return Result.default_internal_error(interface=self.interface_type,\n                                             exec_code=error_code,\n                                             info=f\"Internal error\"\n                                                  f\" {modular_name}.\"\n                                                  f\"{function_name}\").set_origin(mod_function_name)\n\n    if not tb_run_function_with_state:\n        function_data, _ = function_data\n        function = function_data.get('func')\n    else:\n        function_data, function = function_data\n\n    if not function:\n        self.logger.warning(Style.RED(f\"Function {function_name} not found\"))\n        return Result.default_internal_error(interface=self.interface_type,\n                                             exec_code=404,\n                                             info=f\"function not found function\").set_origin(mod_function_name)\n\n    self.logger.info(f\"Profiling function\")\n    if inspect.iscoroutinefunction(function):\n        raise ValueError(f\"Fuction {function_name} is Async use a_run_any\")\n    else:\n        return self.fuction_runner(function, function_data, args, kwargs)\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.run_http","title":"<code>run_http(self, mod_function_name, function_name=None, args_=None, kwargs_=None, method='GET', *args, **kwargs)</code>  <code>async</code>","text":"<p>run a function remote via http / https</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>async def run_http(self, mod_function_name: Enum or str or tuple, function_name=None,\n                   args_=None,\n                   kwargs_=None, method=\"GET\",\n                   *args, **kwargs):\n    if kwargs_ is not None and not kwargs:\n        kwargs = kwargs_\n    if args_ is not None and not args:\n        args = args_\n\n    modular_name = mod_function_name\n    function_name = function_name\n\n    if isinstance(mod_function_name, str) and isinstance(function_name, str):\n        mod_function_name = (mod_function_name, function_name)\n\n    if isinstance(mod_function_name, tuple):\n        modular_name, function_name = mod_function_name\n    elif isinstance(mod_function_name, list):\n        modular_name, function_name = mod_function_name[0], mod_function_name[1]\n    elif isinstance(mod_function_name, Enum):\n        modular_name, function_name = mod_function_name.__class__.NAME.value, mod_function_name.value\n\n\n    r = await self.session.fetch(f\"/api/{modular_name}/{function_name}{'?' + args_ if args_ is not None else ''}\",\n                                 data=kwargs, method=method)\n    return await r.json()\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.run_runnable","title":"<code>run_runnable(self, name, **kwargs)</code>  <code>async</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>async def run_runnable(self, name, **kwargs):\n    from ..runabel import runnable_dict as runnable_dict_func\n    if name not in self.runnable.keys():\n        self.runnable = {**self.runnable, **runnable_dict_func(s=name, remote=True)}\n    if name in self.runnable.keys():\n        if inspect.iscoroutinefunction(self.runnable[name]):\n            return await self.runnable[name](get_app(from_=\"runner\"), self.args_sto, **kwargs)\n        else:\n            return self.runnable[name](get_app(from_=\"runner\"), self.args_sto, **kwargs)\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.save_autocompletion_dict","title":"<code>save_autocompletion_dict(self)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def save_autocompletion_dict(self):\n    autocompletion_dict = {}\n    for module_name, module in self.functions.items():\n        data = {}\n        for function_name, function_data in self.functions[module_name].items():\n            if not isinstance(function_data, dict):\n                continue\n            data[function_name] = {arg: None for arg in\n                                   function_data.get(\"params\", [])}  # TODO get default from sig\n            if len(data[function_name].keys()) == 0:\n                data[function_name] = None\n        autocompletion_dict[module_name] = data if len(data.keys()) &gt; 0 else None\n    self.config_fh.add_to_save_file_handler(\"auto~~~~~~\", str(autocompletion_dict))\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.save_exit","title":"<code>save_exit(self)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def save_exit(self):\n    self.logger.info(f\"save exiting saving data to {self.config_fh.file_handler_filename} states of {self.debug=}\")\n    self.config_fh.add_to_save_file_handler(self.keys[\"debug\"], str(self.debug))\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.save_initialized_module","title":"<code>save_initialized_module(self, tools_class, spec)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def save_initialized_module(self, tools_class, spec):\n    tools_class.spec = spec\n    live_tools_class = tools_class(app=self)\n    return live_tools_class\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.save_instance","title":"<code>save_instance(self, instance, modular_id, spec='app', instance_type='file/application', tools_class=None)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def save_instance(self, instance, modular_id, spec='app', instance_type=\"file/application\", tools_class=None):\n\n    if modular_id in self.functions and tools_class is None:\n        if self.functions[modular_id].get(f\"{spec}_instance\", None) is None:\n            self.functions[modular_id][f\"{spec}_instance\"] = instance\n            self.functions[modular_id][f\"{spec}_instance_type\"] = instance_type\n        else:\n            self.print(\"ERROR OVERRIDE\")\n            raise ImportError(f\"Module already known {modular_id}\")\n\n        on_start = self.functions[modular_id].get(\"on_start\")\n        if on_start is not None:\n            i = 1\n            for f in on_start:\n                try:\n                    f_, e = self.get_function((modular_id, f), state=True, specification=spec)\n                    if e == 0:\n                        self.logger.info(Style.GREY(f\"Running On start {f} {i}/{len(on_start)}\"))\n                        o = f_()\n                        if o is not None:\n                            self.print(f\"Function On start result: {o}\")\n                    else:\n                        self.logger.warning(f\"starting function not found {e}\")\n                except Exception as e:\n                    self.logger.debug(Style.YELLOW(\n                        Style.Bold(f\"modular:{modular_id}.{f} on_start error {i}/{len(on_start)} -&gt; {e}\")))\n                finally:\n                    i += 1\n\n    elif tools_class is not None:\n        if modular_id not in self.functions:\n            self.functions[modular_id] = {}\n        self.functions[modular_id][f\"{spec}_instance\"] = tools_class\n        self.functions[modular_id][f\"{spec}_instance_type\"] = instance_type\n\n        try:\n            if not hasattr(tools_class, 'tools'):\n                tools_class.tools = {\"Version\": tools_class.get_version, 'name': tools_class.name}\n            for function_name in list(tools_class.tools.keys()):\n                t_function_name = function_name.lower()\n                if t_function_name != \"all\" and t_function_name != \"name\":\n                    self.tb(function_name, mod_name=modular_id)(tools_class.tools.get(function_name))\n            self.functions[modular_id][f\"{spec}_instance_type\"] += \"/BC\"\n        except Exception as e:\n            self.logger.error(f\"Starting Module {modular_id} compatibility failed with : {e}\")\n            pass\n    elif modular_id not in self.functions and tools_class is None:\n        self.functions[modular_id] = {}\n        self.functions[modular_id][f\"{spec}_instance\"] = instance\n        self.functions[modular_id][f\"{spec}_instance_type\"] = instance_type\n\n    else:\n        raise ImportError(f\"Modular {modular_id} is not a valid mod\")\n\n    return instance if tools_class is None else tools_class\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.save_load","title":"<code>save_load(self, modname, spec='app')</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def save_load(self, modname, spec='app'):\n    self.logger.debug(f\"Save load module {modname}\")\n    if not modname:\n        self.logger.warning(\"no filename specified\")\n        return False\n    try:\n        return self.load_mod(modname, spec=spec)\n    except ModuleNotFoundError as e:\n        self.logger.error(Style.RED(f\"Module {modname} not found\"))\n        self.debug_rains(e)\n\n    return False\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.save_registry_as_enums","title":"<code>save_registry_as_enums(self, directory, filename)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def save_registry_as_enums(self, directory: str, filename: str):\n    # Ordner erstellen, falls nicht vorhanden\n    if not os.path.exists(directory):\n        os.makedirs(directory)\n\n    # Dateipfad vorbereiten\n    filepath = os.path.join(directory, filename)\n\n    # Enum-Klassen als Strings generieren\n    enum_classes = [f'\"\"\"Automatic generated by ToolBox v = {self.version}\"\"\"'\n                    f'\\nfrom enum import Enum\\nfrom dataclasses import dataclass'\n                    f'\\n\\n\\n']\n    for module, functions in self.functions.items():\n        if module.startswith(\"APP_INSTANCE\"):\n            continue\n        class_name = module\n        enum_members = \"\\n    \".join(\n            [\n                f\"{func_name.upper().replace('-', '')}:\"\n                f\" str = '{func_name}'  \"\n                f\"# Input: ({fuction_data['params'] if isinstance(fuction_data, dict) else ''}),\"\n                f\" Output: {fuction_data['signature'].return_annotation if isinstance(fuction_data, dict) else 'None'}\"\n                for func_name, fuction_data in functions.items()])\n        enum_class = (f'@dataclass\\nclass {class_name.upper().replace(\".\", \"_\").replace(\"-\", \"\")}(Enum):'\n                      f\"\\n    NAME = '{class_name}'\\n    {enum_members}\")\n        enum_classes.append(enum_class)\n\n    # Enums in die Datei schreiben\n    data = \"\\n\\n\\n\".join(enum_classes)\n    if len(data) &lt; 12:\n        raise ValueError(\n            \"Invalid Enums Loosing content pleas delete it ur self in the (utils/system/all_functions_enums.py) or add mor new stuff :}\")\n    with open(filepath, 'w') as file:\n        file.write(data)\n\n    print(Style.Bold(Style.BLUE(f\"Enums gespeichert in {filepath}\")))\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.set_logger","title":"<code>set_logger(self, debug=False)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def set_logger(self, debug=False):\n    if \"test\" in self.prefix and not debug:\n        logger, logging_filename = setup_logging(logging.NOTSET, name=\"toolbox-test\", interminal=True,\n                                                 file_level=logging.NOTSET, app_name=self.id)\n        logger_info_str = \"in Test Mode\"\n    elif \"live\" in self.prefix and not debug:\n        logger, logging_filename = setup_logging(logging.DEBUG, name=\"toolbox-live\", interminal=False,\n                                                 file_level=logging.WARNING, app_name=self.id)\n        logger_info_str = \"in Live Mode\"\n        # setup_logging(logging.WARNING, name=\"toolbox-live\", is_online=True\n        #              , online_level=logging.WARNING).info(\"Logger initialized\")\n    elif \"debug\" in self.prefix or self.prefix.endswith(\"D\"):\n        self.prefix = self.prefix.replace(\"-debug\", '').replace(\"debug\", '')\n        logger, logging_filename = setup_logging(logging.DEBUG, name=\"toolbox-debug\", interminal=True,\n                                                 file_level=logging.WARNING, app_name=self.id)\n        logger_info_str = \"in debug Mode\"\n        self.debug = True\n    elif debug:\n        logger, logging_filename = setup_logging(logging.DEBUG, name=f\"toolbox-{self.prefix}-debug\",\n                                                 interminal=True,\n                                                 file_level=logging.DEBUG, app_name=self.id)\n        logger_info_str = \"in args debug Mode\"\n    else:\n        logger, logging_filename = setup_logging(logging.ERROR, name=f\"toolbox-{self.prefix}\", app_name=self.id)\n        logger_info_str = \"in Default\"\n\n    return logger_info_str, logger, logging_filename\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.set_runnable","title":"<code>set_runnable(self, r)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def set_runnable(self, r):\n    self.runnable = r\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.show_console","title":"<code>show_console(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>@staticmethod\ndef show_console(*args, **kwargs):\n    \"\"\"proxi attr\"\"\"\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.sprint","title":"<code>sprint(self, text, *args, **kwargs)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def sprint(self, text, *args, **kwargs):\n    if text is None:\n        return True\n    # self.logger.info(f\"Output : {text}\")\n    print(Style.CYAN(f\"System${self.id}:\"), end=\" \")\n    if isinstance(text, str) and kwargs == {} and text:\n        stram_print(text + ' '.join(args))\n        print()\n    else:\n        print(text, *args, **kwargs)\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.tb","title":"<code>tb(self, name=None, mod_name='', helper='', version=None, test=True, restrict_in_virtual_mode=False, api=False, initial=False, exit_f=False, test_only=False, memory_cache=False, file_cache=False, request_as_kwarg=False, row=False, state=None, level=-1, memory_cache_max_size=100, memory_cache_ttl=300, samples=None, interface=None, pre_compute=None, post_compute=None, api_methods=None)</code>","text":"<p>A decorator for registering and configuring functions within a module.</p> <p>This decorator is used to wrap functions with additional functionality such as caching, API conversion, and lifecycle management (initialization and exit). It also handles the registration of the function in the module's function registry.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name to register the function under. Defaults to the function's own name.</p> <code>None</code> <code>mod_name</code> <code>str</code> <p>The name of the module the function belongs to.</p> <code>''</code> <code>helper</code> <code>str</code> <p>A helper string providing additional information about the function.</p> <code>''</code> <code>version</code> <code>str or None</code> <p>The version of the function or module.</p> <code>None</code> <code>test</code> <code>bool</code> <p>Flag to indicate if the function is for testing purposes.</p> <code>True</code> <code>restrict_in_virtual_mode</code> <code>bool</code> <p>Flag to restrict the function in virtual mode.</p> <code>False</code> <code>api</code> <code>bool</code> <p>Flag to indicate if the function is part of an API.</p> <code>False</code> <code>initial</code> <code>bool</code> <p>Flag to indicate if the function should be executed at initialization.</p> <code>False</code> <code>exit_f</code> <code>bool</code> <p>Flag to indicate if the function should be executed at exit.</p> <code>False</code> <code>test_only</code> <code>bool</code> <p>Flag to indicate if the function should only be used for testing.</p> <code>False</code> <code>memory_cache</code> <code>bool</code> <p>Flag to enable memory caching for the function.</p> <code>False</code> <code>request_as_kwarg</code> <code>bool</code> <p>Flag to get request if the fuction is calld from api.</p> <code>False</code> <code>file_cache</code> <code>bool</code> <p>Flag to enable file caching for the function.</p> <code>False</code> <code>row</code> <code>bool</code> <p>rather to auto wrap the result in Result type default False means no row data aka result type</p> <code>False</code> <code>state</code> <code>bool or None</code> <p>Flag to indicate if the function maintains state.</p> <code>None</code> <code>level</code> <code>int</code> <p>The level of the function, used for prioritization or categorization.</p> <code>-1</code> <code>memory_cache_max_size</code> <code>int</code> <p>Maximum size of the memory cache.</p> <code>100</code> <code>memory_cache_ttl</code> <code>int</code> <p>Time-to-live for the memory cache entries.</p> <code>300</code> <code>samples</code> <code>list or dict or None</code> <p>Samples or examples of function usage.</p> <code>None</code> <code>interface</code> <code>str</code> <p>The interface type for the function.</p> <code>None</code> <code>pre_compute</code> <code>callable</code> <p>A function to be called before the main function.</p> <code>None</code> <code>post_compute</code> <code>callable</code> <p>A function to be called after the main function.</p> <code>None</code> <code>api_methods</code> <code>list[str]</code> <p>default [\"AUTO\"] (GET if not params, POST if params) , GET, POST, PUT or DELETE.</p> <code>None</code> <p>Returns:</p> Type Description <code>function</code> <p>The decorated function with additional processing and registration capabilities.</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def tb(self, name=None,\n       mod_name: str = \"\",\n       helper: str = \"\",\n       version: str or None = None,\n       test: bool = True,\n       restrict_in_virtual_mode: bool = False,\n       api: bool = False,\n       initial: bool = False,\n       exit_f: bool = False,\n       test_only: bool = False,\n       memory_cache: bool = False,\n       file_cache: bool = False,\n       request_as_kwarg: bool = False,\n       row: bool = False,\n       state: bool or None = None,\n       level: int = -1,\n       memory_cache_max_size: int = 100,\n       memory_cache_ttl: int = 300,\n       samples: list or dict or None = None,\n       interface: ToolBoxInterfaces or None or str = None,\n       pre_compute=None,\n       post_compute=None,\n       api_methods=None,\n       ):\n    \"\"\"\nA decorator for registering and configuring functions within a module.\n\nThis decorator is used to wrap functions with additional functionality such as caching, API conversion, and lifecycle management (initialization and exit). It also handles the registration of the function in the module's function registry.\n\nArgs:\n    name (str, optional): The name to register the function under. Defaults to the function's own name.\n    mod_name (str, optional): The name of the module the function belongs to.\n    helper (str, optional): A helper string providing additional information about the function.\n    version (str or None, optional): The version of the function or module.\n    test (bool, optional): Flag to indicate if the function is for testing purposes.\n    restrict_in_virtual_mode (bool, optional): Flag to restrict the function in virtual mode.\n    api (bool, optional): Flag to indicate if the function is part of an API.\n    initial (bool, optional): Flag to indicate if the function should be executed at initialization.\n    exit_f (bool, optional): Flag to indicate if the function should be executed at exit.\n    test_only (bool, optional): Flag to indicate if the function should only be used for testing.\n    memory_cache (bool, optional): Flag to enable memory caching for the function.\n    request_as_kwarg (bool, optional): Flag to get request if the fuction is calld from api.\n    file_cache (bool, optional): Flag to enable file caching for the function.\n    row (bool, optional): rather to auto wrap the result in Result type default False means no row data aka result type\n    state (bool or None, optional): Flag to indicate if the function maintains state.\n    level (int, optional): The level of the function, used for prioritization or categorization.\n    memory_cache_max_size (int, optional): Maximum size of the memory cache.\n    memory_cache_ttl (int, optional): Time-to-live for the memory cache entries.\n    samples (list or dict or None, optional): Samples or examples of function usage.\n    interface (str, optional): The interface type for the function.\n    pre_compute (callable, optional): A function to be called before the main function.\n    post_compute (callable, optional): A function to be called after the main function.\n    api_methods (list[str], optional): default [\"AUTO\"] (GET if not params, POST if params) , GET, POST, PUT or DELETE.\n\nReturns:\n    function: The decorated function with additional processing and registration capabilities.\n\"\"\"\n    if interface is None:\n        interface = \"tb\"\n    if test_only and 'test' not in self.id:\n        return lambda *args, **kwargs: args\n    return self._create_decorator(interface,\n                                  name,\n                                  mod_name,\n                                  level=level,\n                                  restrict_in_virtual_mode=restrict_in_virtual_mode,\n                                  helper=helper,\n                                  api=api,\n                                  version=version,\n                                  initial=initial,\n                                  exit_f=exit_f,\n                                  test=test,\n                                  samples=samples,\n                                  state=state,\n                                  pre_compute=pre_compute,\n                                  post_compute=post_compute,\n                                  memory_cache=memory_cache,\n                                  file_cache=file_cache,\n                                  request_as_kwarg=request_as_kwarg,\n                                  row=row,\n                                  api_methods=api_methods,\n                                  memory_cache_max_size=memory_cache_max_size,\n                                  memory_cache_ttl=memory_cache_ttl)\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.toolbox.App.watch_mod","title":"<code>watch_mod(self, mod_name, spec='app', loc='toolboxv2.mods.', use_thread=True, path_name=None)</code>","text":"<p>proxi attr</p> Source code in <code>toolboxv2/utils/toolbox.py</code> <pre><code>def watch_mod(self, mod_name, spec='app', loc=\"toolboxv2.mods.\", use_thread=True, path_name=None):\n    if path_name is None:\n        path_name = mod_name\n    is_file = os.path.isfile(self.start_dir + '/mods/' + path_name + '.py')\n    import watchfiles\n    def helper():\n        paths = f'mods/{path_name}' + ('.py' if is_file else '')\n        self.print(f'Watching Path: {paths}')\n        for changes in watchfiles.watch(paths):\n            print(changes)\n            self.reload_mod(mod_name, spec, is_file, loc)\n\n    if not use_thread:\n        helper()\n    else:\n        threading.Thread(target=helper, daemon=True).start()\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.system.main_tool.MainTool.__init__","title":"<code>__init__(self, *args, **kwargs)</code>  <code>special</code>","text":"<p>Standard constructor used for arguments pass Do not override. Use ainit instead</p> Source code in <code>toolboxv2/utils/system/main_tool.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"\n    Standard constructor used for arguments pass\n    Do not override. Use __ainit__ instead\n    \"\"\"\n    self.__storedargs = args, kwargs\n    self.async_initialized = False\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.system.main_tool.MainTool.get_version","title":"<code>get_version(self)</code>","text":"<p>\"Returns the version</p> Source code in <code>toolboxv2/utils/system/main_tool.py</code> <pre><code>def get_version(self) -&gt; str:\n    \"\"\"\"Returns the version\"\"\"\n    return self.version\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.utils.system.main_tool.MainTool.webInstall","title":"<code>webInstall(self, user_instance, construct_render)</code>","text":"<p>\"Returns a web installer for the given user instance and construct render template</p> Source code in <code>toolboxv2/utils/system/main_tool.py</code> <pre><code>def webInstall(self, user_instance, construct_render) -&gt; str:\n    \"\"\"\"Returns a web installer for the given user instance and construct render template\"\"\"\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.runabel.chat","title":"<code>chat</code>","text":""},{"location":"toolboxv2/#toolboxv2.runabel.chat.init","title":"<code>init(app, pbar)</code>  <code>async</code>","text":"<p>Initial Modules</p> Source code in <code>toolboxv2/runabel/chat.py</code> <pre><code>async def init(app: App, pbar):\n    \"\"\"Initial Modules\"\"\"\n    if not app.mod_online(\"CloudM\"):\n        await app.init_module(\"CloudM\")\n    pbar.update()\n    if not app.mod_online(\"SocketManager\"):\n        await app.init_module(\"SocketManager\")\n    pbar.update()\n    if not app.mod_online(\"EventManager\"):\n        await app.init_module(\"EventManager\")\n    pbar.update()\n    # try:\n    #     if not app.mod_online(\"audio\"):\n    #         app.load_mod(\"audio\")\n    #     pbar.write(\"audio Online\")\n    # except ImportError and RuntimeError as e:\n    #     app.print(Style.YELLOW(f\"Error importing audio module no voice active\"))\n    #     pbar.write(\"audio Offline\")\n    pbar.update()\n</code></pre>"},{"location":"toolboxv2/#toolboxv2.runabel.demon","title":"<code>demon</code>","text":""},{"location":"toolboxv2/#toolboxv2.runabel.demon.run","title":"<code>run(app, args, programmabel_interface=False, as_server=True)</code>  <code>async</code>","text":"<p>The daemon runner is responsible for running a lightweight toolbox instance in the background The name of the daemon instance is also the communication bridge.</p> <p>workflow :</p> <p>run the daemon as a .py script the daemon will then kill the Terminal interface and runs in the background the daemon can then be used to start other toolbox runnabel processes like the cli thru a nothe Terminal by simply naming the new instance as the daemon. This new generated instance the shadow daemon is then used to control the daemon.</p> <p>crate the daemon</p> <pre><code>$ ToolBoxV2 -m daemon -n main # use the same name default is main\n</code></pre> <p>creating the shadow daemon</p> <pre><code>same device\n\n    $ ToolBoxV2 -m AnyMode[(default), cli, api]\n\n    # to stop the daemon\n    $ ToolBoxV2 -m daemon --kill\n\nremote\n\n    $ ToolBoxV2 -m AnyMode[(default), cli, api] -n (full-name) --remote\n                                                optional --remote-direct-key [key] --host [host] --port [port]\n</code></pre> Source code in <code>toolboxv2/runabel/demon.py</code> <pre><code>async def run(app: App, args: AppArgs, programmabel_interface=False, as_server=True):\n    \"\"\"\n    The daemon runner is responsible for running a lightweight toolbox instance in the background\n    The name of the daemon instance is also the communication bridge.\n\n    workflow :\n\n    run the daemon as a .py script the daemon will then kill the Terminal interface and runs in the background\n    the daemon can then be used to start other toolbox runnabel processes like the cli thru a nothe Terminal by simply\n    naming the new instance as the daemon. This new generated instance the shadow daemon is then used to control the daemon.\n\n    crate the daemon\n\n        $ ToolBoxV2 -m daemon -n main # use the same name default is main\n\n    creating the shadow daemon\n\n        same device\n\n            $ ToolBoxV2 -m AnyMode[(default), cli, api]\n\n            # to stop the daemon\n            $ ToolBoxV2 -m daemon --kill\n\n        remote\n\n            $ ToolBoxV2 -m AnyMode[(default), cli, api] -n (full-name) --remote\n                                                        optional --remote-direct-key [key] --host [host] --port [port]\n\n    \"\"\"\n\n    from toolboxv2.mods.SocketManager import SocketType\n    # Start a New daemon\n\n    status = 'unknown'\n\n    client = await app.a_run_any('SocketManager', 'create_socket',\n                         name=\"daemon\",\n                         host=\"localhost\" if args.host == '0.0.0.0' else args.host,\n                         port=62436 if args.port == 8000 else args.port,\n                         type_id=SocketType.client,\n                         max_connections=-1,\n                         endpoint_port=None,\n                         return_full_object=True)\n    sender = None\n    receiver_queue = None\n\n    as_client = True\n\n    if client is None:\n        as_client = False\n\n    if as_client:\n        as_client = client.get('connection_error') == 0\n\n    if as_client:\n        status = 'client'\n        sender = client.get('sender')\n        receiver_queue = client.get('receiver_queue')\n\n    if not as_client and as_server:\n        status = 'server'\n        server_controler = app.run_any('SocketManager', 'tbSocketController',\n                                       name=\"daemon\", host=args.host, port=62436)\n        if programmabel_interface:\n            return 0, server_controler[\"get_status\"], server_controler[\"stop_server\"]\n\n        def helper():\n            t0 = time.perf_counter()\n            while time.perf_counter() &lt; t0 + 9999:\n                time.sleep(2)\n                for status_info in server_controler[\"get_status\"]():\n                    if status_info == \"KEEPALIVE\":\n                        t0 = time.perf_counter()\n                    print(f\"Server status :\", status_info)\n                    if status_info == \"Server closed\":\n                        break\n\n        t_1 = Thread(target=helper)\n        t_1.start()\n        gc = app.run_any(TBEF.CLI_FUNCTIONS.GET_CHARACTER)\n        for data in gc:\n            if data.word == \"EXIT\":\n                server_controler[\"stop_server\"]()\n            if data.char == \"x\":\n                server_controler[\"stop_server\"]()\n            print(data.char, data.word)\n        t_1.join()\n\n    if status != 'client':\n        app.logger.info(f\"closing daemon {app.id}'{status}'\")\n        return -1, status, status\n\n    if programmabel_interface:\n        return 1, sender, receiver_queue\n\n    alive = True\n\n    while alive:\n        user_input = input(\"input dict from :\")\n        if user_input == \"exit\":\n            user_input = '{\"exit\": True}'\n            alive = False\n        await sender(eval(user_input))\n\n        if not receiver_queue.empty():\n            print(receiver_queue.get())\n\n    # {\n    #     'socket': socket,\n    #     'receiver_socket': r_socket,\n    #     'host': host,\n    #     'port': port,\n    #     'p2p-port': endpoint_port,\n    #     'sender': send,\n    #     'receiver_queue': receiver_queue,\n    #     'connection_error': connection_error\n    # }\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use ToolBox in a project:</p> <pre><code>import toolboxv2\n</code></pre>"},{"location":"utils/app/","title":"Main App","text":""},{"location":"utils/app/#summary","title":"Summary","text":"<p>The init method initializes an instance of the App class. It sets up the necessary directories, logger, and other configurations based on the provided prefix and command line arguments.</p>"},{"location":"utils/app/#example-usage","title":"Example Usage","text":"<p><code>app = App(prefix=\"myapp\", args=AppArgs().default())</code></p>"},{"location":"utils/app/#code-analysis","title":"Code Analysis","text":""},{"location":"utils/app/#inputs","title":"Inputs","text":"<p><code>prefix (str): The prefix for the application. args (AppArgs): Command line arguments for the application.</code></p>"},{"location":"utils/app/#flow","title":"Flow","text":"<ul> <li>Get the absolute path of the current file and determine the system flag (Linux, Mac, or Windows).</li> <li>Set the current working directory to the directory of the current file.</li> <li>Set the start directory to the current working directory.</li> <li>Set the path for the last used application prefix file.</li> <li>If no prefix is provided, check if the last used prefix exists in the file and use it as the prefix.</li> <li>If a prefix is provided, write it to the last used prefix file.</li> <li>Set the application ID by combining the prefix and the node name.</li> <li>Set up the necessary directories for data, configuration, and information files.</li> <li>Print the start directory and set up the logger.</li> <li>If the init argument is provided, add the start directory to the system path and initialize the toolbox.</li> <li>Set up the keys and defaults for the configuration file.</li> <li>Load the configuration file and get the debug mode value.</li> <li>Set up the runnable, development mode, and functions attributes.</li> <li>Set up the interface type, prefix, module list, and other attributes.</li> <li>Print the system information and version.</li> <li>If the update argument is provided, pull the latest changes from the git repository.</li> <li>If the get_version argument is provided, get the version of the specified module.</li> <li>Log the completion of the initialization.</li> </ul>"},{"location":"utils/app/#outputs","title":"Outputs","text":"<p>An instance of the App class with the necessary configurations and attributes set up.</p>"},{"location":"utils/cli/","title":"Cli","text":"<ul> <li>Parse command line arguments using the parse_args function.</li> <li>Initialize variables and folders for the application.</li> <li>Handle options to delete configuration and data files.</li> <li>Handle options for testing, profiling, and background application running.</li> <li>Create an instance of the application using the get_app function.</li> <li>Handle options for background application, proxy application, and debug mode.</li> <li>Load all modules from files if specified.</li> <li>Save function enums to a file if specified.</li> <li>Print the version of each module if specified.</li> <li>Profile the execution of all functions if specified.</li> <li>Run the application in the specified mode.</li> <li>Handle options for Docker and killing the application.</li> <li>Exit the application and clean up if necessary.</li> </ul>"},{"location":"utils/example_mod/","title":"Example mod","text":"<p>Grundlegende Struktur eines Toolboxv2-Moduls</p> <pre><code>Importe und Abh\u00e4ngigkeiten: Das Modul beginnt mit dem Import notwendiger Bibliotheken und Modulen. Es behandelt auch fehlende Abh\u00e4ngigkeiten durch bedingte Importe und setzt Flags, um die Verf\u00fcgbarkeit von optionalen Features zu \u00fcberpr\u00fcfen.\n\nModul- und Funktionsdeklarationen: Das Modul definiert Funktionen und Klassen, die f\u00fcr die Funktionalit\u00e4t des Moduls zentral sind. Dekoratoren werden verwendet, um Funktionen innerhalb der Toolbox zu registrieren.\n\nExport und Versionierung: Das Modul definiert Variablen f\u00fcr den Namen (Name), die exportierten Funktionen (export) und die Version (version). Diese werden genutzt, um das Modul innerhalb der Toolboxv2 eindeutig zu identifizieren und zu verwalten.\n\nFunktionsdefinitionen: Funktionen werden mit dem @export-Dekorator markiert, um sie innerhalb der Toolbox verf\u00fcgbar zu machen. Funktionen k\u00f6nnen Parameter, R\u00fcckgabewerte und spezifische Logik enthalten, die f\u00fcr die Toolbox relevant sind.\n\nDatenklassen: Datenklassen werden verwendet, um komplexe Datenstrukturen zu definieren, die von den Funktionen des Moduls genutzt werden.\n\nFehlerbehandlung und Kompatibilit\u00e4tspr\u00fcfungen: Das Modul enth\u00e4lt Logik zur Fehlerbehandlung und zur \u00dcberpr\u00fcfung der Kompatibilit\u00e4t mit erforderlichen Bibliotheken.\n</code></pre> <p>Erstellung eines g\u00fcltigen Toolboxv2-Moduls</p> <p>Um ein neues Modul f\u00fcr die Toolboxv2 zu erstellen, sollten Sie folgende Schritte beachten:</p> <pre><code>Modulstruktur definieren: Folgen Sie der oben beschriebenen Grundstruktur, um Ihr Modul zu organisieren.\n\nAbh\u00e4ngigkeiten kl\u00e4ren: Importieren Sie alle notwendigen Bibliotheken und behandeln Sie fehlende Abh\u00e4ngigkeiten angemessen.\n\nFunktionen exportieren: Verwenden Sie den @export-Dekorator, um Funktionen zu markieren, die von der Toolbox genutzt werden sollen. Stellen Sie sicher, dass jede Funktion eine eindeutige Signatur hat und mit den erforderlichen Parametern und R\u00fcckgabetypen dokumentiert ist.\n\nDokumentation und Versionierung: Dokumentieren Sie Ihr Modul und seine Funktionen ausf\u00fchrlich. Definieren Sie eine Versionsnummer, um die Verwaltung von Modulupdates zu erleichtern.\n\nTesten: Testen Sie Ihr Modul gr\u00fcndlich, um sicherzustellen, dass es wie erwartet funktioniert und mit der Toolboxv2 kompatibel ist.\n</code></pre> <p>Beispielcode f\u00fcr ein einfaches Toolboxv2-Modul</p> <p>`python &gt;= 3.9</p> <pre><code>from toolboxv2 import get_app, export\n\nName = 'mein_modul'\nexport = get_app(Name).tb\nversion = '1.0.0'\n\n@export(mod_name=Name, version=version)\ndef meine_funktion():\n    # Implementierung Ihrer Funktion\n    return \"Hallo Toolboxv2!\"\n\n# Weitere Funktionen und Logik hier...\n</code></pre> <p>` Diese Dokumentation bietet einen \u00dcberblick \u00fcber die Erstellung eines Toolboxv2-Moduls. Beachten Sie, dass die spezifischen Anforderungen und Funktionen Ihres Moduls von den Zielen und der Architektur der Toolboxv2 abh\u00e4ngen.</p>"}]}