{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to ToolBoxV2 \ud83e\uddf0 \u00b6 ToolBoxV2 is a flexible, modular framework designed for creating and managing a wide range of tools, functions, and complete applications. It supports deployment locally, on the web, or as cross-platform desktop/mobile applications. At its core, ToolBoxV2 integrates a Python backend with a Rust server and a Tauri-based UI, offering a powerful and versatile development experience. Free software: Custom License Officel Web page: https://simplecore.com/ GitHub Repository: https://github.com/MarkinHaus/ToolBoxV2 Key Goals & Features \u00b6 ToolBoxV2 aims to simplify the development and usage of digital tools by: \ud83d\udd0c Modularity: Build applications from reusable Python modules ( mods ) and utilities ( utils ). \u2699\ufe0f Automation: Facilitate automation of tasks through CLI interactions and programmable APIs. \ud83c\udf10 Cross-Platform Interfaces: Develop Desktop Applications using Tauri (Rust + Web UI). Create Web Applications with the tbjs frontend framework. Interact via a robust Command Line Interface (CLI) . \ud83d\ude80 Performance & Safety: Leverage Rust for backend server components (Actix) and Python for scripting and application logic. \ud83e\udde9 Extensibility: Easily create and integrate new functions, tools, or full mini-applications. System Independence: Strives to make applications and tools runnable across different operating systems. Unified Development: Provides a cohesive environment for Python, Rust, and web technologies. Getting Started \u00b6 Installation: For detailed instructions on how to install the core Python library or set up the full-stack development environment, please see the Installation Guide . 1 2 # Quick install for the Python package pip install ToolBoxV2 Developer Guide: To learn how to create modules, use the App class, and interact with the CLI, explore the full Developer Documentation . Explore the Code: Dive into the GitHub Repository to see the project structure and contribute. Example Use Cases \u00b6 ToolBoxV2 can be used for: * Personal productivity tools (calendars, note-takers). * Development utilities and automation scripts. * Custom internal business applications. * Interactive data processing and visualization tools. * And much more! Credits \u00b6 This package was created with inspiration from project structures like those generated by Cookiecutter and templates such as giswqs/pypackage . \u00a9 2022\u20132025 Markin Hausmanns \u2013 All rights reserved.","title":"Home"},{"location":"#welcome-to-toolboxv2","text":"ToolBoxV2 is a flexible, modular framework designed for creating and managing a wide range of tools, functions, and complete applications. It supports deployment locally, on the web, or as cross-platform desktop/mobile applications. At its core, ToolBoxV2 integrates a Python backend with a Rust server and a Tauri-based UI, offering a powerful and versatile development experience. Free software: Custom License Officel Web page: https://simplecore.com/ GitHub Repository: https://github.com/MarkinHaus/ToolBoxV2","title":"Welcome to ToolBoxV2 \ud83e\uddf0"},{"location":"#key-goals-features","text":"ToolBoxV2 aims to simplify the development and usage of digital tools by: \ud83d\udd0c Modularity: Build applications from reusable Python modules ( mods ) and utilities ( utils ). \u2699\ufe0f Automation: Facilitate automation of tasks through CLI interactions and programmable APIs. \ud83c\udf10 Cross-Platform Interfaces: Develop Desktop Applications using Tauri (Rust + Web UI). Create Web Applications with the tbjs frontend framework. Interact via a robust Command Line Interface (CLI) . \ud83d\ude80 Performance & Safety: Leverage Rust for backend server components (Actix) and Python for scripting and application logic. \ud83e\udde9 Extensibility: Easily create and integrate new functions, tools, or full mini-applications. System Independence: Strives to make applications and tools runnable across different operating systems. Unified Development: Provides a cohesive environment for Python, Rust, and web technologies.","title":"Key Goals &amp; Features"},{"location":"#getting-started","text":"Installation: For detailed instructions on how to install the core Python library or set up the full-stack development environment, please see the Installation Guide . 1 2 # Quick install for the Python package pip install ToolBoxV2 Developer Guide: To learn how to create modules, use the App class, and interact with the CLI, explore the full Developer Documentation . Explore the Code: Dive into the GitHub Repository to see the project structure and contribute.","title":"Getting Started"},{"location":"#example-use-cases","text":"ToolBoxV2 can be used for: * Personal productivity tools (calendars, note-takers). * Development utilities and automation scripts. * Custom internal business applications. * Interactive data processing and visualization tools. * And much more!","title":"Example Use Cases"},{"location":"#credits","text":"This package was created with inspiration from project structures like those generated by Cookiecutter and templates such as giswqs/pypackage . \u00a9 2022\u20132025 Markin Hausmanns \u2013 All rights reserved.","title":"Credits"},{"location":"changelog/","text":"Changelog \u00b6 v0.0.1 - Date \u00b6 Improvement : TBD New Features : TBD","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#v001-date","text":"Improvement : TBD New Features : TBD","title":"v0.0.1 - Date"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/MarkinHaus/ToolBoxV2/issues . If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with bug and help wanted is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with enhancement and help wanted is open to whoever wants to implement it. Write Documentation \u00b6 ToolBox could always use more documentation, whether as part of the official ToolBox docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/MarkinHaus/ToolBoxV2/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! \u00b6 Ready to contribute? Here's how to set up ToolBoxV2 for local development. Fork the ToolBoxV2 repo on GitHub. Clone your fork locally: 1 $ git clone git@github.com:MarkinHaus/ToolBoxV2.git Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development: 1 2 3 $ mkvirtualenv ToolBoxV2 $ cd ToolBoxV2/ $ python setup.py develop Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass flake8 and the tests, including testing other Python versions with tox: 1 2 3 $ flake8 ToolBoxV2 tests $ python setup.py test or pytest $ tox To get flake8 and tox, just pip install them into your virtualenv. Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.rst. The pull request should work for Python 3.5, 3.6, 3.7 and 3.8, and for PyPy. Check https://github.com/MarkinHaus/ToolBoxV2/pull_requests and make sure that the tests pass for all supported Python versions.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/MarkinHaus/ToolBoxV2/issues . If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with bug and help wanted is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with enhancement and help wanted is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"ToolBox could always use more documentation, whether as part of the official ToolBox docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/MarkinHaus/ToolBoxV2/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up ToolBoxV2 for local development. Fork the ToolBoxV2 repo on GitHub. Clone your fork locally: 1 $ git clone git@github.com:MarkinHaus/ToolBoxV2.git Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development: 1 2 3 $ mkvirtualenv ToolBoxV2 $ cd ToolBoxV2/ $ python setup.py develop Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass flake8 and the tests, including testing other Python versions with tox: 1 2 3 $ flake8 ToolBoxV2 tests $ python setup.py test or pytest $ tox To get flake8 and tox, just pip install them into your virtualenv. Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.rst. The pull request should work for Python 3.5, 3.6, 3.7 and 3.8, and for PyPy. Check https://github.com/MarkinHaus/ToolBoxV2/pull_requests and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"faq/","text":"FAQ \u00b6 Gei isaa redy in conda with cuda # conda install pytorch torchvision torchaudio pytorch-cuda=12.4 -c pytorch -c nvidia \u00b6 Errors : \u00b6 ModuleNotFoundError: No module named '_cffi_backend' fix -> pip -vvv install --upgrade --force-reinstall cffi \u00b6 extraes : langchain-experimental astor PyAudio Pebble transformers litellm nltk gpt4all SpeechRecognition chromadb pydub duckduckgo-search langchain-groq beautifulsoup4 langchain-huggingface langchain langchain-chroma langchain-ollama tiktoken \u00b6","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#gei-isaa-redy-in-conda-with-cuda-conda-install-pytorch-torchvision-torchaudio-pytorch-cuda124-c-pytorch-c-nvidia","text":"","title":"Gei isaa redy in conda with cuda # conda install pytorch torchvision torchaudio pytorch-cuda=12.4 -c pytorch -c nvidia"},{"location":"faq/#errors","text":"","title":"Errors :"},{"location":"faq/#modulenotfounderror-no-module-named-_cffi_backend-fix-pip-vvv-install-upgrade-force-reinstall-cffi","text":"","title":"ModuleNotFoundError: No module named '_cffi_backend' fix -&gt; pip -vvv install --upgrade --force-reinstall cffi"},{"location":"faq/#extraes-langchain-experimental-astor-pyaudio-pebble-transformers-litellm-nltk-gpt4all-speechrecognition-chromadb-pydub-duckduckgo-search-langchain-groq-beautifulsoup4-langchain-huggingface-langchain-langchain-chroma-langchain-ollama-tiktoken","text":"","title":"extraes : langchain-experimental astor PyAudio Pebble transformers litellm nltk gpt4all SpeechRecognition chromadb pydub duckduckgo-search langchain-groq beautifulsoup4 langchain-huggingface langchain langchain-chroma langchain-ollama tiktoken"},{"location":"installation/","text":"ToolBoxV2: Installation Guide \u00b6 This guide provides instructions for installing ToolBoxV2, whether you need just the core Python library or the full-stack application including the Rust server and Tauri/Web frontend. 1. Installing the Core Python Library \u00b6 This method is suitable if you primarily need to use ToolBoxV2 as a Python library within your own projects or want to develop Python-based modules for it. Option A: Stable Release from PyPI (Recommended) \u00b6 This is the preferred method for installing the latest stable release of the ToolBoxV2 Python package. Ensure you have Python and pip: If you don't have Python and pip installed, this Python installation guide can help. We recommend Python 3.10 or newer. Install ToolBoxV2: Open your terminal or command prompt and run: 1 pip install ToolBoxV2 Consider using a virtual environment to manage project dependencies: 1 2 3 4 5 6 7 8 # Create a virtual environment (optional but recommended) python -m venv .venv # Activate it (Windows) # .venv\\Scripts\\activate # Activate it (macOS/Linux) # source .venv/bin/activate pip install ToolBoxV2 Option B: From Source (Latest Development Version) \u00b6 This method allows you to get the very latest code from the GitHub repository, which might include new features or changes not yet in a stable release. Clone the Repository: 1 2 git clone https://github.com/MarkinHaus/ToolBoxV2.git cd ToolBoxV2 Install in Editable Mode: This installs the package from your local clone, and any changes you make to the source code will be immediately reflected in your environment. Using pip: 1 2 # Recommended: Activate a virtual environment first pip install -e . Using uv (a fast Python package installer and resolver): 1 2 # Recommended: Activate a virtual environment first uv pip install -e . Using the provided script (sets up environment): This script creates a virtual environment and installs dependencies. 1 2 chmod +x install_python_env.sh ./install_python_env.sh Option C: Directly from GitHub with pip \u00b6 You can also install directly from the GitHub repository without cloning it first: 1 pip install git+https://github.com/MarkinHaus/ToolBoxV2.git 2. Installing the Full Stack Desktop/Web Application \u00b6 This setup is for developers who want to run or develop the complete ToolBoxV2 application, including the Python backend, Rust server (Actix), and the Tauri-based desktop application or tbjs web frontend. Prerequisites \u00b6 Ensure you have the following installed on your system: Python: Version 3.10 or higher. Rust and Cargo: Install from rust-lang.org . Node.js and npm/pnpm: Install from nodejs.org . We recommend pnpm for managing Node.js dependencies in this project. Install pnpm globally: npm install -g pnpm Tauri CLI: Install using Cargo: cargo install tauri-cli Ensure the virtual environment created by the script (or one you created manually) is activated for the subsequent steps. Install Node.js Dependencies and Build Rust Components: From the root of the ToolBoxV2 directory: 1 pnpm install # Installs Node.js dependencies for tbjs and Tauri frontend The Rust backend ( src-core/ ) and Tauri components are typically built as part of the pnpm scripts defined in package.json . If you need to build the Rust core manually: 1 2 # (Usually not needed if using pnpm scripts) # cargo build --release --manifest-path src-core/Cargo.toml the build step is Usually handled by the api flow Running the Application in CLI \u00b6 Row python runner tb 1 tb -c { MOD_NAME } { FUCTION_NAME } { AGRGS } --kwargs name:value or run in ipython 1 tb --ipy Running the Application in Server mode for web and Desktop \u00b6 Refer to the scripts in the package.json file for various ways to run and build the application. Common commands include: Web Development Mode (tbjs frontend with hot-reloading): 1 2 pnpm dev # or live This typically starts the Rust server and the web frontend development server. Tauri Desktop Application (Development Mode): 1 pnpm tauri dev This will build and run the Tauri desktop application with hot-reloading for the frontend. Build Tauri Desktop Application (Production): 1 pnpm tauri build # Or a custom script like `pnpm tauriB` if defined This creates a distributable binary of the desktop application. For more specific build and run commands, please consult the scripts section in the package.json file located in the ToolBoxV2 repository root or use the CLI help: 1 2 3 tb --help # or python -m toolboxv2 --help","title":"Installation"},{"location":"installation/#toolboxv2-installation-guide","text":"This guide provides instructions for installing ToolBoxV2, whether you need just the core Python library or the full-stack application including the Rust server and Tauri/Web frontend.","title":"ToolBoxV2: Installation Guide"},{"location":"installation/#1-installing-the-core-python-library","text":"This method is suitable if you primarily need to use ToolBoxV2 as a Python library within your own projects or want to develop Python-based modules for it.","title":"1. Installing the Core Python Library"},{"location":"installation/#option-a-stable-release-from-pypi-recommended","text":"This is the preferred method for installing the latest stable release of the ToolBoxV2 Python package. Ensure you have Python and pip: If you don't have Python and pip installed, this Python installation guide can help. We recommend Python 3.10 or newer. Install ToolBoxV2: Open your terminal or command prompt and run: 1 pip install ToolBoxV2 Consider using a virtual environment to manage project dependencies: 1 2 3 4 5 6 7 8 # Create a virtual environment (optional but recommended) python -m venv .venv # Activate it (Windows) # .venv\\Scripts\\activate # Activate it (macOS/Linux) # source .venv/bin/activate pip install ToolBoxV2","title":"Option A: Stable Release from PyPI (Recommended)"},{"location":"installation/#option-b-from-source-latest-development-version","text":"This method allows you to get the very latest code from the GitHub repository, which might include new features or changes not yet in a stable release. Clone the Repository: 1 2 git clone https://github.com/MarkinHaus/ToolBoxV2.git cd ToolBoxV2 Install in Editable Mode: This installs the package from your local clone, and any changes you make to the source code will be immediately reflected in your environment. Using pip: 1 2 # Recommended: Activate a virtual environment first pip install -e . Using uv (a fast Python package installer and resolver): 1 2 # Recommended: Activate a virtual environment first uv pip install -e . Using the provided script (sets up environment): This script creates a virtual environment and installs dependencies. 1 2 chmod +x install_python_env.sh ./install_python_env.sh","title":"Option B: From Source (Latest Development Version)"},{"location":"installation/#option-c-directly-from-github-with-pip","text":"You can also install directly from the GitHub repository without cloning it first: 1 pip install git+https://github.com/MarkinHaus/ToolBoxV2.git","title":"Option C: Directly from GitHub with pip"},{"location":"installation/#2-installing-the-full-stack-desktopweb-application","text":"This setup is for developers who want to run or develop the complete ToolBoxV2 application, including the Python backend, Rust server (Actix), and the Tauri-based desktop application or tbjs web frontend.","title":"2. Installing the Full Stack Desktop/Web Application"},{"location":"installation/#prerequisites","text":"Ensure you have the following installed on your system: Python: Version 3.10 or higher. Rust and Cargo: Install from rust-lang.org . Node.js and npm/pnpm: Install from nodejs.org . We recommend pnpm for managing Node.js dependencies in this project. Install pnpm globally: npm install -g pnpm Tauri CLI: Install using Cargo: cargo install tauri-cli Ensure the virtual environment created by the script (or one you created manually) is activated for the subsequent steps. Install Node.js Dependencies and Build Rust Components: From the root of the ToolBoxV2 directory: 1 pnpm install # Installs Node.js dependencies for tbjs and Tauri frontend The Rust backend ( src-core/ ) and Tauri components are typically built as part of the pnpm scripts defined in package.json . If you need to build the Rust core manually: 1 2 # (Usually not needed if using pnpm scripts) # cargo build --release --manifest-path src-core/Cargo.toml the build step is Usually handled by the api flow","title":"Prerequisites"},{"location":"installation/#running-the-application-in-cli","text":"Row python runner tb 1 tb -c { MOD_NAME } { FUCTION_NAME } { AGRGS } --kwargs name:value or run in ipython 1 tb --ipy","title":"Running the Application in CLI"},{"location":"installation/#running-the-application-in-server-mode-for-web-and-desktop","text":"Refer to the scripts in the package.json file for various ways to run and build the application. Common commands include: Web Development Mode (tbjs frontend with hot-reloading): 1 2 pnpm dev # or live This typically starts the Rust server and the web frontend development server. Tauri Desktop Application (Development Mode): 1 pnpm tauri dev This will build and run the Tauri desktop application with hot-reloading for the frontend. Build Tauri Desktop Application (Production): 1 pnpm tauri build # Or a custom script like `pnpm tauriB` if defined This creates a distributable binary of the desktop application. For more specific build and run commands, please consult the scripts section in the package.json file located in the ToolBoxV2 repository root or use the CLI help: 1 2 3 tb --help # or python -m toolboxv2 --help","title":"Running the Application in Server mode for web and Desktop"},{"location":"toolboxv2/","text":"toolboxv2 API Reference \u00b6 This section provides an API reference for key components directly available from the toolboxv2 package. Core Application & Tooling \u00b6 ::: toolboxv2.utils.toolbox.App options: show_root_heading: true show_source: false ::: toolboxv2.MainTool options: show_root_heading: true show_source: false ::: toolboxv2.get_app options: show_root_heading: true show_source: false System Utilities & Configuration \u00b6 ::: toolboxv2.FileHandler options: show_root_heading: true show_source: false heading_level: 3 ::: toolboxv2.utils options: show_root_heading: true heading_level: 3 show_bases: false show_submodules: true ::: toolboxv2.show_console options: show_root_heading: true show_source: false heading_level: 3 Logging \u00b6 ::: toolboxv2.get_logger options: show_root_heading: true show_source: false heading_level: 3 ::: toolboxv2.setup_logging options: show_root_heading: true show_source: false heading_level: 3 Styling & Console Output \u00b6 ::: toolboxv2.Style options: show_root_heading: true show_source: false heading_level: 3 ::: toolboxv2.Spinner options: show_root_heading: true show_source: false heading_level: 3 ::: toolboxv2.remove_styles options: show_root_heading: true show_source: false heading_level: 3 Data Types & Structures \u00b6 ::: toolboxv2.AppArgs options: show_root_heading: true show_source: false heading_level: 3 ::: toolboxv2.Result options: show_root_heading: true show_source: false heading_level: 3 ::: toolboxv2.ApiResult options: show_root_heading: true show_source: false heading_level: 3 ::: toolboxv2.RequestData options: show_root_heading: true show_source: false heading_level: 3 Security \u00b6 ::: toolboxv2.Code options: show_root_heading: true show_source: false heading_level: 3 Modules & Flows \u00b6 ::: toolboxv2.mods options: show_root_heading: true heading_level: 3 show_submodules: true ::: toolboxv2.flows_dict options: show_root_heading: true show_source: false heading_level: 3 ::: toolboxv2.TBEF options: show_root_heading: true show_source: false heading_level: 3 Other Exposed Items \u00b6 ::: toolboxv2.ToolBox_over options: show_root_heading: true show_source: false","title":"toolboxv2 module"},{"location":"toolboxv2/#toolboxv2-api-reference","text":"This section provides an API reference for key components directly available from the toolboxv2 package.","title":"toolboxv2 API Reference"},{"location":"toolboxv2/#core-application-tooling","text":"::: toolboxv2.utils.toolbox.App options: show_root_heading: true show_source: false ::: toolboxv2.MainTool options: show_root_heading: true show_source: false ::: toolboxv2.get_app options: show_root_heading: true show_source: false","title":"Core Application &amp; Tooling"},{"location":"toolboxv2/#system-utilities-configuration","text":"::: toolboxv2.FileHandler options: show_root_heading: true show_source: false heading_level: 3 ::: toolboxv2.utils options: show_root_heading: true heading_level: 3 show_bases: false show_submodules: true ::: toolboxv2.show_console options: show_root_heading: true show_source: false heading_level: 3","title":"System Utilities &amp; Configuration"},{"location":"toolboxv2/#logging","text":"::: toolboxv2.get_logger options: show_root_heading: true show_source: false heading_level: 3 ::: toolboxv2.setup_logging options: show_root_heading: true show_source: false heading_level: 3","title":"Logging"},{"location":"toolboxv2/#styling-console-output","text":"::: toolboxv2.Style options: show_root_heading: true show_source: false heading_level: 3 ::: toolboxv2.Spinner options: show_root_heading: true show_source: false heading_level: 3 ::: toolboxv2.remove_styles options: show_root_heading: true show_source: false heading_level: 3","title":"Styling &amp; Console Output"},{"location":"toolboxv2/#data-types-structures","text":"::: toolboxv2.AppArgs options: show_root_heading: true show_source: false heading_level: 3 ::: toolboxv2.Result options: show_root_heading: true show_source: false heading_level: 3 ::: toolboxv2.ApiResult options: show_root_heading: true show_source: false heading_level: 3 ::: toolboxv2.RequestData options: show_root_heading: true show_source: false heading_level: 3","title":"Data Types &amp; Structures"},{"location":"toolboxv2/#security","text":"::: toolboxv2.Code options: show_root_heading: true show_source: false heading_level: 3","title":"Security"},{"location":"toolboxv2/#modules-flows","text":"::: toolboxv2.mods options: show_root_heading: true heading_level: 3 show_submodules: true ::: toolboxv2.flows_dict options: show_root_heading: true show_source: false heading_level: 3 ::: toolboxv2.TBEF options: show_root_heading: true show_source: false heading_level: 3","title":"Modules &amp; Flows"},{"location":"toolboxv2/#other-exposed-items","text":"::: toolboxv2.ToolBox_over options: show_root_heading: true show_source: false","title":"Other Exposed Items"},{"location":"usage/","text":"ToolBoxV2 Developer Guide \u00b6 Based on the provided documentation, here's a comprehensive guide on how to use the ToolBoxV2 framework for building applications. Introduction \u00b6 ToolBoxV2 is a Python framework that provides a structured approach to building applications with standardized request handling and response formatting. It consists of two main components: RequestData Classes - For handling HTTP requests with strong typing Result Class - For standardized response handling and error management Setting Up Your Application \u00b6 Creating a Module \u00b6 Start by initializing your application module: 1 2 3 4 5 6 7 from toolboxv2 import get_app , App , RequestData , Result from typing import Dict , Optional # Define your module MOD_NAME = \"YOUR_MODULE_NAME\" version = \"1.0\" export = get_app ( \"{MODULE-NAME.SUB-MODULE}\" ) . tb Registering Functions \u00b6 Use the @export decorator to register functions within your module: 1 2 3 4 @export ( mod_name = MOD_NAME , version = version ) def your_function (): # Function logic here return Result . ok ( data = \"Success\" ) Function Types \u00b6 Standard System Functions \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # Basic function with App parameter @export ( mod_name = MOD_NAME , version = version , row = True ) def system_function ( app : App ): # Implementation return \"Raw return value\" # Will be returned as-is because row=True # Function without App parameter @export ( mod_name = MOD_NAME , version = version ) def function_without_app (): # Implementation return Result . ok ( data = \"Success\" ) # Function with arguments @export ( mod_name = MOD_NAME , version = version ) def function_with_args ( name : str ) -> Result : # Implementation return Result . ok ( data = name ) # Function returning raw data @export ( mod_name = MOD_NAME , version = version , row = True ) def function_with_args_kwargs ( name : str , nickname : Optional [ str ] = None ) -> str : if nickname is None : nickname = \"\" return name + nickname # Returned as raw string Async Functions \u00b6 1 2 3 4 5 @export ( mod_name = MOD_NAME , version = version , row = True ) async def async_function ( app : App ): # Async implementation result = await some_async_operation () return result API Endpoints \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # API endpoint with request parameter @export ( mod_name = MOD_NAME , api = True , version = \"1.0\" , request_as_kwarg = True ) async def get_data ( request : Optional [ RequestData ] = None ): if request : query_params = request . query_params # Process query parameters return Result . json ( data = { \"status\" : \"success\" }) # API endpoint with App and Request parameters @export ( mod_name = MOD_NAME , api = True , version = \"1.0\" , request_as_kwarg = True ) async def get_user_data ( app , request : Optional [ RequestData ] = None ): # Implementation using app and request return Result . ok ( data = { \"user\" : \"data\" }) # API endpoint with specific HTTP methods @export ( mod_name = MOD_NAME , api = True , version = \"1.0\" , api_methods = [ 'PUT' , 'POST' ]) async def update_data ( app , data : Dict ): # Process the JSON data received in the request body return Result . ok ( data = data ) # API endpoint handling form data @export ( mod_name = MOD_NAME , api = True , version = \"1.0\" , api_methods = [ 'PUT' , 'POST' ]) async def submit_form ( app , form_data : Dict ): # Process form data return Result . ok ( data = form_data ) Working with Request Data \u00b6 Accessing Request Information \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @export ( mod_name = MOD_NAME , api = True , version = \"1.0\" , request_as_kwarg = True ) async def process_request ( request : Optional [ RequestData ] = None ): if request : # Access method and path method = request . method path = request . path # Access headers user_agent = request . headers . user_agent content_type = request . headers . content_type custom_header = request . headers . extra_headers . get ( 'x-custom-header' ) # Access query parameters query_params = request . query_params search_term = query_params . get ( 'search' ) # Access form data or JSON body if request . form_data : form_values = request . form_data if request . body and request . content_type == 'application/json' : json_data = request . body return Result . ok ( data = \"Request processed\" ) Accessing Session Information \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 @export ( mod_name = MOD_NAME , api = True , version = \"1.0\" , request_as_kwarg = True ) async def get_user_session ( request : Optional [ RequestData ] = None ): if request and hasattr ( request , 'session' ): # Access session data session_id = request . session . SiID user_name = request . session . user_name session_level = request . session . level # Access custom session data custom_data = request . session . extra_data . get ( 'custom_key' ) return Result . ok ( data = { \"user\" : user_name }) Working with Results \u00b6 Creating Different Types of Responses \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @export ( mod_name = MOD_NAME , api = True , version = \"1.0\" ) async def response_examples ( app ): # Choose the appropriate response type based on your needs # 1. Standard success response return Result . ok ( data = { \"key\" : \"value\" }, info = \"Operation completed successfully\" ) # 2. JSON response return Result . json ( data = { \"status\" : \"online\" , \"version\" : \"1.0\" }, info = \"API status retrieved\" ) # 3. HTML response return Result . html ( data = \"<html><body><h1>Welcome</h1></body></html>\" , info = \"Page rendered\" ) # 4. Text response return Result . text ( text_data = \"Plain text content\" , content_type = \"text/plain\" ) # 5. Binary file response return Result . binary ( data = binary_data , content_type = \"application/pdf\" , download_name = \"report.pdf\" ) # 6. Redirect response return Result . redirect ( url = \"/dashboard\" , status_code = 302 ) Error Handling \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @export ( mod_name = MOD_NAME , version = version ) def process_with_validation ( user_input ): # Validate input if not user_input : return Result . default_user_error ( info = \"Empty input is not allowed\" , exec_code = 400 ) # Process valid input try : processed_data = process_data ( user_input ) return Result . ok ( data = processed_data ) except Exception as e : return Result . default_sys_error ( info = f \"Processing error: { str ( e ) } \" , exec_code = 500 ) Using lazy_return for Simplified Error Handling \u00b6 1 2 3 4 5 6 7 8 9 10 11 @export ( mod_name = MOD_NAME , version = version ) def validate_and_process ( data ): # Validate data validation_result = validate_data ( data ) # If validation fails, return the error # If validation succeeds, return the processed data return validation_result . lazy_return ( 'user' , # Use user error if validation fails data = { \"processed\" : True , \"original\" : data } # Return this if successful ) Streaming Responses \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @export ( mod_name = MOD_NAME , api = True , version = \"1.0\" ) async def stream_data (): async def generator (): for i in range ( 10 ): yield { \"chunk\" : i } await asyncio . sleep ( 0.5 ) async def cleanup (): # Cleanup resources when the stream closes print ( \"Stream closed, performing cleanup\" ) return Result . stream ( stream_generator = generator (), info = \"Streaming data chunks\" , cleanup_func = cleanup ) Advanced Features \u00b6 Caching \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 # Memory caching @export ( mod_name = MOD_NAME , version = version , memory_cache = True , memory_cache_max_size = 100 , memory_cache_ttl = 300 ) def cached_function ( key ): # Expensive operation here return Result . ok ( data = compute_expensive_data ( key )) # File caching @export ( mod_name = MOD_NAME , version = version , file_cache = True ) def file_cached_function ( key ): # Expensive operation here return Result . ok ( data = compute_expensive_data ( key )) Background Functions \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Memory caching @export ( mod_name = MOD_NAME , version = version ) def function_with_log_running_bg_call (): # Expensive operation here def sync_bg_function (): print ( \"running in gb\" ) compute_expensive_function () return Result . ok ( data = \"Starting processing\" ) . task ( sync_bg_function ) # File caching @export ( mod_name = MOD_NAME , version = version ) async def function_with_log_running_bg_call (): # Expensive operation here async def bg_function (): print ( \"running in gb\" ) await compute_expensive_function () return Result . ok ( data = \"Starting processing\" ) . task ( bg_function ()) Lifecycle Management \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Initialization function @export ( mod_name = MOD_NAME , version = version , initial = True ) def initialize_module ( app : App ): # Called when the module is loaded print ( f \"Initializing { MOD_NAME } module\" ) # Set up resources, connections, etc. return Result . ok ( info = \"Module initialized\" ) # Exit function @export ( mod_name = MOD_NAME , version = version , exit_f = True ) def cleanup_module ( app : App ): # Called when the application is shutting down print ( f \"Cleaning up { MOD_NAME } module\" ) # Release resources, close connections, etc. return Result . ok ( info = \"Module cleaned up\" ) Pre/Post Compute Functions \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def log_before_execution ( func , * args , ** kwargs ): print ( f \"Executing { func . __name__ } with args: { args } , kwargs: { kwargs } \" ) return args , kwargs def log_after_execution ( result , func , * args , ** kwargs ): print ( f \"Function { func . __name__ } returned: { result } \" ) return result @export ( mod_name = MOD_NAME , version = version , pre_compute = log_before_execution , post_compute = log_after_execution ) def monitored_function ( name ): # Function logic return Result . ok ( data = f \"Hello, { name } !\" ) URL Patterns for API Endpoints \u00b6 API endpoints are accessible using the following URL patterns: Regular API: /api/MOD_NAME/{function_name}?param1=value1&param2=value2 Server-Sent Events (streaming): /sse/MOD_NAME/{function_name}?param1=value1&param2=value2","title":"Usage"},{"location":"usage/#toolboxv2-developer-guide","text":"Based on the provided documentation, here's a comprehensive guide on how to use the ToolBoxV2 framework for building applications.","title":"ToolBoxV2 Developer Guide"},{"location":"usage/#introduction","text":"ToolBoxV2 is a Python framework that provides a structured approach to building applications with standardized request handling and response formatting. It consists of two main components: RequestData Classes - For handling HTTP requests with strong typing Result Class - For standardized response handling and error management","title":"Introduction"},{"location":"usage/#setting-up-your-application","text":"","title":"Setting Up Your Application"},{"location":"usage/#creating-a-module","text":"Start by initializing your application module: 1 2 3 4 5 6 7 from toolboxv2 import get_app , App , RequestData , Result from typing import Dict , Optional # Define your module MOD_NAME = \"YOUR_MODULE_NAME\" version = \"1.0\" export = get_app ( \"{MODULE-NAME.SUB-MODULE}\" ) . tb","title":"Creating a Module"},{"location":"usage/#registering-functions","text":"Use the @export decorator to register functions within your module: 1 2 3 4 @export ( mod_name = MOD_NAME , version = version ) def your_function (): # Function logic here return Result . ok ( data = \"Success\" )","title":"Registering Functions"},{"location":"usage/#function-types","text":"","title":"Function Types"},{"location":"usage/#standard-system-functions","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # Basic function with App parameter @export ( mod_name = MOD_NAME , version = version , row = True ) def system_function ( app : App ): # Implementation return \"Raw return value\" # Will be returned as-is because row=True # Function without App parameter @export ( mod_name = MOD_NAME , version = version ) def function_without_app (): # Implementation return Result . ok ( data = \"Success\" ) # Function with arguments @export ( mod_name = MOD_NAME , version = version ) def function_with_args ( name : str ) -> Result : # Implementation return Result . ok ( data = name ) # Function returning raw data @export ( mod_name = MOD_NAME , version = version , row = True ) def function_with_args_kwargs ( name : str , nickname : Optional [ str ] = None ) -> str : if nickname is None : nickname = \"\" return name + nickname # Returned as raw string","title":"Standard System Functions"},{"location":"usage/#async-functions","text":"1 2 3 4 5 @export ( mod_name = MOD_NAME , version = version , row = True ) async def async_function ( app : App ): # Async implementation result = await some_async_operation () return result","title":"Async Functions"},{"location":"usage/#api-endpoints","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # API endpoint with request parameter @export ( mod_name = MOD_NAME , api = True , version = \"1.0\" , request_as_kwarg = True ) async def get_data ( request : Optional [ RequestData ] = None ): if request : query_params = request . query_params # Process query parameters return Result . json ( data = { \"status\" : \"success\" }) # API endpoint with App and Request parameters @export ( mod_name = MOD_NAME , api = True , version = \"1.0\" , request_as_kwarg = True ) async def get_user_data ( app , request : Optional [ RequestData ] = None ): # Implementation using app and request return Result . ok ( data = { \"user\" : \"data\" }) # API endpoint with specific HTTP methods @export ( mod_name = MOD_NAME , api = True , version = \"1.0\" , api_methods = [ 'PUT' , 'POST' ]) async def update_data ( app , data : Dict ): # Process the JSON data received in the request body return Result . ok ( data = data ) # API endpoint handling form data @export ( mod_name = MOD_NAME , api = True , version = \"1.0\" , api_methods = [ 'PUT' , 'POST' ]) async def submit_form ( app , form_data : Dict ): # Process form data return Result . ok ( data = form_data )","title":"API Endpoints"},{"location":"usage/#working-with-request-data","text":"","title":"Working with Request Data"},{"location":"usage/#accessing-request-information","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @export ( mod_name = MOD_NAME , api = True , version = \"1.0\" , request_as_kwarg = True ) async def process_request ( request : Optional [ RequestData ] = None ): if request : # Access method and path method = request . method path = request . path # Access headers user_agent = request . headers . user_agent content_type = request . headers . content_type custom_header = request . headers . extra_headers . get ( 'x-custom-header' ) # Access query parameters query_params = request . query_params search_term = query_params . get ( 'search' ) # Access form data or JSON body if request . form_data : form_values = request . form_data if request . body and request . content_type == 'application/json' : json_data = request . body return Result . ok ( data = \"Request processed\" )","title":"Accessing Request Information"},{"location":"usage/#accessing-session-information","text":"1 2 3 4 5 6 7 8 9 10 11 12 @export ( mod_name = MOD_NAME , api = True , version = \"1.0\" , request_as_kwarg = True ) async def get_user_session ( request : Optional [ RequestData ] = None ): if request and hasattr ( request , 'session' ): # Access session data session_id = request . session . SiID user_name = request . session . user_name session_level = request . session . level # Access custom session data custom_data = request . session . extra_data . get ( 'custom_key' ) return Result . ok ( data = { \"user\" : user_name })","title":"Accessing Session Information"},{"location":"usage/#working-with-results","text":"","title":"Working with Results"},{"location":"usage/#creating-different-types-of-responses","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @export ( mod_name = MOD_NAME , api = True , version = \"1.0\" ) async def response_examples ( app ): # Choose the appropriate response type based on your needs # 1. Standard success response return Result . ok ( data = { \"key\" : \"value\" }, info = \"Operation completed successfully\" ) # 2. JSON response return Result . json ( data = { \"status\" : \"online\" , \"version\" : \"1.0\" }, info = \"API status retrieved\" ) # 3. HTML response return Result . html ( data = \"<html><body><h1>Welcome</h1></body></html>\" , info = \"Page rendered\" ) # 4. Text response return Result . text ( text_data = \"Plain text content\" , content_type = \"text/plain\" ) # 5. Binary file response return Result . binary ( data = binary_data , content_type = \"application/pdf\" , download_name = \"report.pdf\" ) # 6. Redirect response return Result . redirect ( url = \"/dashboard\" , status_code = 302 )","title":"Creating Different Types of Responses"},{"location":"usage/#error-handling","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @export ( mod_name = MOD_NAME , version = version ) def process_with_validation ( user_input ): # Validate input if not user_input : return Result . default_user_error ( info = \"Empty input is not allowed\" , exec_code = 400 ) # Process valid input try : processed_data = process_data ( user_input ) return Result . ok ( data = processed_data ) except Exception as e : return Result . default_sys_error ( info = f \"Processing error: { str ( e ) } \" , exec_code = 500 )","title":"Error Handling"},{"location":"usage/#using-lazy_return-for-simplified-error-handling","text":"1 2 3 4 5 6 7 8 9 10 11 @export ( mod_name = MOD_NAME , version = version ) def validate_and_process ( data ): # Validate data validation_result = validate_data ( data ) # If validation fails, return the error # If validation succeeds, return the processed data return validation_result . lazy_return ( 'user' , # Use user error if validation fails data = { \"processed\" : True , \"original\" : data } # Return this if successful )","title":"Using lazy_return for Simplified Error Handling"},{"location":"usage/#streaming-responses","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @export ( mod_name = MOD_NAME , api = True , version = \"1.0\" ) async def stream_data (): async def generator (): for i in range ( 10 ): yield { \"chunk\" : i } await asyncio . sleep ( 0.5 ) async def cleanup (): # Cleanup resources when the stream closes print ( \"Stream closed, performing cleanup\" ) return Result . stream ( stream_generator = generator (), info = \"Streaming data chunks\" , cleanup_func = cleanup )","title":"Streaming Responses"},{"location":"usage/#advanced-features","text":"","title":"Advanced Features"},{"location":"usage/#caching","text":"1 2 3 4 5 6 7 8 9 10 11 12 # Memory caching @export ( mod_name = MOD_NAME , version = version , memory_cache = True , memory_cache_max_size = 100 , memory_cache_ttl = 300 ) def cached_function ( key ): # Expensive operation here return Result . ok ( data = compute_expensive_data ( key )) # File caching @export ( mod_name = MOD_NAME , version = version , file_cache = True ) def file_cached_function ( key ): # Expensive operation here return Result . ok ( data = compute_expensive_data ( key ))","title":"Caching"},{"location":"usage/#background-functions","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Memory caching @export ( mod_name = MOD_NAME , version = version ) def function_with_log_running_bg_call (): # Expensive operation here def sync_bg_function (): print ( \"running in gb\" ) compute_expensive_function () return Result . ok ( data = \"Starting processing\" ) . task ( sync_bg_function ) # File caching @export ( mod_name = MOD_NAME , version = version ) async def function_with_log_running_bg_call (): # Expensive operation here async def bg_function (): print ( \"running in gb\" ) await compute_expensive_function () return Result . ok ( data = \"Starting processing\" ) . task ( bg_function ())","title":"Background Functions"},{"location":"usage/#lifecycle-management","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Initialization function @export ( mod_name = MOD_NAME , version = version , initial = True ) def initialize_module ( app : App ): # Called when the module is loaded print ( f \"Initializing { MOD_NAME } module\" ) # Set up resources, connections, etc. return Result . ok ( info = \"Module initialized\" ) # Exit function @export ( mod_name = MOD_NAME , version = version , exit_f = True ) def cleanup_module ( app : App ): # Called when the application is shutting down print ( f \"Cleaning up { MOD_NAME } module\" ) # Release resources, close connections, etc. return Result . ok ( info = \"Module cleaned up\" )","title":"Lifecycle Management"},{"location":"usage/#prepost-compute-functions","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 def log_before_execution ( func , * args , ** kwargs ): print ( f \"Executing { func . __name__ } with args: { args } , kwargs: { kwargs } \" ) return args , kwargs def log_after_execution ( result , func , * args , ** kwargs ): print ( f \"Function { func . __name__ } returned: { result } \" ) return result @export ( mod_name = MOD_NAME , version = version , pre_compute = log_before_execution , post_compute = log_after_execution ) def monitored_function ( name ): # Function logic return Result . ok ( data = f \"Hello, { name } !\" )","title":"Pre/Post Compute Functions"},{"location":"usage/#url-patterns-for-api-endpoints","text":"API endpoints are accessible using the following URL patterns: Regular API: /api/MOD_NAME/{function_name}?param1=value1&param2=value2 Server-Sent Events (streaming): /sse/MOD_NAME/{function_name}?param1=value1&param2=value2","title":"URL Patterns for API Endpoints"},{"location":"utils/","text":"ToolBoxV2: The App Class \u00b6 The App class is the central singleton instance in ToolBoxV2, responsible for managing the application's lifecycle, configuration, module loading, and core functionalities. It's typically accessed via the get_app() utility function. Initialization \u00b6 The App instance is initialized with a prefix and AppArgs (command-line arguments). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from toolboxv2 import App , AppArgs , get_app # Example: Initialize or get the App instance # The prefix helps differentiate multiple App instances if needed, # and is often used in directory naming. args = AppArgs () . default () # Or parsed from sys.argv in __main__.py app_instance = get_app ( prefix = \"my_app_instance\" , args = args ) # Accessing key attributes: print ( f \"App ID: { app_instance . id } \" ) print ( f \"Version: { app_instance . version } \" ) print ( f \"Start Directory: { app_instance . start_dir } \" ) print ( f \"Data Directory: { app_instance . data_dir } \" ) print ( f \"Config Directory: { app_instance . config_dir } \" ) print ( f \"Debug Mode: { app_instance . debug } \" ) Key Initialization Steps: \u00b6 System & Paths: Determines the operating system ( system_flag ). Sets the start_dir to the application's root directory. Resolves the prefix : If no prefix is provided, it attempts to load the last used prefix from .data/last-app-prefix.txt . If a prefix is provided, it's saved to this file for future use. Constructs the app_id (e.g., prefix-hostname ). Sets up data_dir , config_dir , and info_dir based on the app_id (e.g., ./.data/prefix-hostname/ ). Sets up appdata directory (OS-specific application data folder). Logging: Initializes a logger ( app.logger ). The logging level and output (terminal/file) can vary based on the prefix (e.g., \"test\", \"live\", \"debug\") and the --debug CLI argument. Configuration: Loads application configuration using FileHandler from a file typically named app_id.config in the config_dir . Defines default configuration keys and defaults (e.g., for macros, helpers, debug status). Core Attributes: version : ToolBoxV2 version, read from pyproject.toml . debug : Boolean, controlled by CLI args and config. dev_modi : Boolean, development mode status from config. functions : A dictionary to store registered functions from modules. modules : A dictionary to store loaded module objects. interface_type : Default ToolBoxInterfaces.native . alive : Boolean, controls the main application loop. args_sto : Stores the parsed AppArgs . loop : The asyncio event loop (initialized later or if already running). session : A Session object for managing user/remote session state. Conditional Actions (based on AppArgs ): args.init : If true, adds start_dir to sys.path . The __main__.py script handles other arguments like --update , --get-version , etc., by calling App methods or other utilities. Core Functionalities \u00b6 Module Management \u00b6 load_mod(mod_name: str, spec='app', mlm='I', **kwargs) / save_load(modname, spec='app') : Loads a module into the application. spec (specification): Used to namespace or categorize the module instance (e.g., 'app' for general, or a specific session ID). Supports different loading mechanisms ( mlm ): 'I' : In-place load (imports the Python module directly). This is the default. 'C' : Copies the module file to a runtime directory before loading (less common). Handles ModuleNotFoundError by attempting to guide the user (e.g., install via CloudM or pip ). Registers the module's exported functions and/or its Tools class instance. Can reload modules if they are already loaded. 1 2 3 4 5 # Load the 'MyModule' my_module_instance = app_instance . load_mod ( \"MyModule\" ) # Or if it's a Tool-based module: # my_tool_instance = app_instance.load_mod(\"MyToolModule\") get_mod(name: str, spec='app') -> ModuleType | MainToolType : Retrieves a loaded module instance. If the module isn't loaded, it attempts to load it. 1 2 3 db_mod = app_instance . get_mod ( \"DB\" ) if db_mod : db_mod . some_db_function () remove_mod(mod_name: str, spec='app', delete=True) / a_remove_mod(...) (async): Unloads a module, calling its on_exit functions if defined. delete=True removes it completely from the functions registry. reload_mod(mod_name: str, spec='app', ...) : Reloads an existing module. Useful for development. watch_mod(mod_name: str, ...) : Monitors a module's source file(s) for changes and automatically reloads it. 1 2 # In development, watch 'MyDevModule' for changes app_instance . watch_mod ( \"MyDevModule\" ) load_all_mods_in_file(working_dir=\"mods\") / a_load_all_mods_in_file(...) (async): Scans the specified directory (default ./mods/ ) and loads all valid Python modules found. Function Registration and Execution \u00b6 @app.tb(...) Decorator (via _create_decorator ): The primary way functions are registered with ToolBoxV2. See example_mod.md for details on usage. This decorator populates the app.functions dictionary. get_function(name: Enum | tuple, metadata=False, state=True, specification='app', ...) : Retrieves a registered function. name : Can be an Enum (from all_functions_enums.py ) or a (module_name, function_name) tuple. metadata=True : Returns a tuple (function_data_dict, callable_function) . state=True : Returns a stateful version of the function (bound to its module instance if applicable). state=False : Returns the raw, stateless function. specification : The context/instance spec to get the function for. run_any(mod_function_name, ..., get_results=False, **kwargs) / a_run_any(...) (async): Executes a registered function by its name (Enum or tuple). Handles argument passing, stateful/stateless execution, and error wrapping into a Result object. get_results=True : Returns the Result object itself. get_results=False (default): Returns the data payload from the Result object if successful. Automatically handles running the function's pre/post compute hooks and caching if configured via @app.tb . 1 2 3 4 5 6 # Synchronous execution result_data = app_instance . run_any (( \"MyModule\" , \"my_function\" ), arg1 = \"hello\" ) full_result_obj = app_instance . run_any (( \"MyModule\" , \"my_function\" ), arg1 = \"hello\" , get_results = True ) # Asynchronous execution async_result_data = await app_instance . a_run_any (( \"MyAsyncModule\" , \"my_async_function\" )) run_http(mod_function_name, function_name=None, method=\"GET\", ...) (async): Executes a function on a remote ToolBoxV2 instance via HTTP, using the app's session object. Application Lifecycle \u00b6 exit() / a_exit() (async): Gracefully shuts down the application. Calls on_exit functions for all loaded modules. Saves configuration. Stops the main application loop ( alive = False ). Cleans up threads and the event loop if applicable. Utilities \u00b6 print(text, *args, **kwargs) / sprint(text, *args, **kwargs) : Styled print functions, prepending System$[app_id]: . sprint is often used for more verbose/system-level messages and can be silenced. debug_rains(e: Exception) : If app.debug is true, prints a full traceback and re-raises the exception. set_flows(r: dict) / run_flows(name: str, **kwargs) : Manages and executes predefined application flows (sequences of operations). get_username() / set_username(username: str) : Manages the application's user identity. save_autocompletion_dict() / get_autocompletion_dict() : Saves/loads a dictionary of modules and their functions for autocompletion features. save_registry_as_enums(directory: str, filename: str) : Generates an all_functions_enums.py -like file from the currently registered functions. execute_all_functions(...) / a_execute_all_functions(...) (async): Runs all registered testable functions (marked with test=True in @app.tb or having samples ). Useful for integration testing and profiling. Can filter by module ( m_query ) and function ( f_query ). Supports profiling via cProfile . run_bg_task(task: Callable) : Runs a synchronous or asynchronous task in a separate background thread with its own event loop. Ensures proper handling of nested asyncio operations within the task. Session Management ( app.session ) \u00b6 The app.session attribute holds an instance of the Session class (from toolboxv2.utils.system.session ). It's used for: * Authenticating with a remote ToolBoxV2 service (e.g., SimpleCore Hub). * Making authenticated HTTP requests ( session.fetch , session.upload_file , session.download_file ). * Manages JWT claims and private key authentication. 1 2 3 4 # Example: Making an authenticated API call # Assumes app.session is already authenticated response_data = await app_instance . session . fetch ( \"/api/MyRemoteModule/get_info\" ) json_payload = await response_data . json () 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ### 2. `cli.md` - Documenting the Command Line Interface This should explain how to use the `tb` (or `python -m toolboxv2`) command-line tool, detailing its arguments and their effects. ```markdown # ToolBoxV2: Command Line Interface (CLI) ToolBoxV2 provides a command-line interface (CLI) for managing and running applications. It's typically invoked as `tb` (if installed globally or via an alias) or `python -m toolboxv2`. ## General Usage ```bash python -m toolboxv2 [options] [sub-commands] # or tb [options] [sub-commands] The CLI script ( __main__.py ) performs the following main steps: 1. Parses command-line arguments. 2. Initializes the App instance via setup_app() (which calls get_app() ). 3. Handles various options to: * Manage application data and configuration. * Control application modes (background, proxy, debug). * Load modules and manage their state. * Run tests or profilers. * Execute specific application flows or commands. Key CLI Arguments \u00b6 The following are some of the primary arguments available. Use tb -h or python -m toolboxv2 -h for a full list. Instance and Mode: -init [name] : Initializes ToolBoxV2 with a specific instance name (default: main ). -n, --name <name> : Specifies an ID for the ToolBox instance (default: main ). This affects data/config directory names. -m, --modi <mode> : Starts a ToolBoxV2 interface/flow (e.g., cli , bg , or custom flows). Default is usually \"cli\". --debug : Starts the application in debug mode (more verbose logging, potentially different behavior). --remote : Starts in remote mode, often for connecting to a proxy or another instance. -bg, --background-application : Starts an interface in the background as a detached process. -bgr, --background-application-runner : Runs the background application logic in the current terminal (for daemons). -fg, --live-application : Starts a proxy interface, connecting to a background daemon. --kill : Kills the currently running local ToolBoxV2 instance (matching the -m <mode> and -n <name> ). Module and Version Management: -l, --load-all-mod-in-files : Loads all modules found in the mods/ directory on startup. -sfe, --save-function-enums-in-file : Generates/updates the all_functions_enums.py file based on loaded modules. Often used with -l . -v, --get-version : Prints the version of ToolBoxV2 and all loaded modules. -i, --install <name> : Installs a module or interface (likely via CloudM module). -r, --remove <name> : Uninstalls a module or interface. -u, --update <name_or_main> : Updates a module/interface or the core ToolBoxV2 ( main ). Development and Testing: --test : Runs all unit tests (typically discovers and runs tests in the tests/ directory). --profiler : Runs all registered testable functions and profiles their execution using cProfile . --ipy : Starts an IPython session with the ToolBoxV2 app pre-loaded. Provides magic commands like %tb save/loadX/load/open/inject . Service Management ( --sm ): Provides a sub-menu for managing ToolBoxV2 as a system service (Linux/systemd or Windows Startup). Options: Init, Start/Stop/Restart, Status, Uninstall, Show/Hide console window (Windows). Log Management ( --lm ): Provides a sub-menu for managing log files (e.g., removing or unstyling logs by date/level). Data and Configuration Management: --delete-config-all : Deletes all configuration files. Use with caution! --delete-data-all : Deletes all data folders. Use with caution! --delete-config : Deletes the configuration file for the named instance. --delete-data : Deletes the data folder for the named instance. Network Configuration (for interfaces): -p, --port <port> : Specifies the port for an interface (default: 5000 or 6587 for background). -w, --host <host> : Specifies the host for an interface (default: 0.0.0.0 ). Direct Command Execution: -c, --command <module_name> <function_name> [arg1 arg2 ...] (can be repeated): Executes a specific function. --kwargs <key=value> (can be repeated): Provides keyword arguments for commands specified with -c . Conda Integration: conda [conda_args...] : Special argument to pass commands directly to a conda_runner.py script (e.g., tb conda env list ). API Runner: api [api_args...] : Special argument to invoke cli_api_runner.py , likely for direct API interactions or testing. GUI: gui : Starts the GUI version of ToolBoxV2 (imports and runs toolboxv2.__gui__.start ). CLI Execution Flow ( __main__.py ) \u00b6 Argument Parsing: parse_args() uses argparse to define and parse all CLI arguments. App Setup ( setup_app() ): Initializes the App instance using get_app() with the parsed arguments and name. Sets up PID file for the current process. Optionally silences app.sprint if not in debug/verbose mode. Loads all modules if -l is specified. Handles --update logic. Background/Live Application Handling: If -bgr : Initializes DaemonApp . If -bg : Starts the application as a detached background process using subprocess.Popen . If -fg (live-application): Attempts to connect to a background daemon using ProxyApp . Action Dispatching: Based on the parsed arguments, it performs actions like: Module installation ( --install ). Log management ( --lm ). Service management ( --sm ). Saving function enums ( -sfe ). Printing versions ( -v ). Running the profiler ( --profiler ). Running flows based on --modi . Handling Docker commands ( --docker ). Killing an existing instance ( --kill ). Executing direct commands ( -c ). Cleanup: Removes the PID file and calls app.a_exit() before exiting. Example CLI Usage \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Get version information python -m toolboxv2 -v # Load all modules and save function enums python -m toolboxv2 -l -sfe # Run a specific function in MyModule python -m toolboxv2 -c MyModule my_function arg_value --kwargs param_name = kwarg_value # Start the application with a custom flow named 'web_server' in debug mode python -m toolboxv2 -m web_server --debug -n my_web_instance # Start a background daemon for the 'bg_processing' flow python -m toolboxv2 -m bg_processing -bg -n background_processor # Connect to the background daemon with a live proxy application python -m toolboxv2 -m cli -fg -n background_processor # Kill the 'web_server' modi instance named 'my_web_instance' python -m toolboxv2 -m web_server --kill -n my_web_instance 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 ### 3. `example_mod.md` - Documenting Module Creation This needs to be updated to accurately reflect the `@app.tb(...)` decorator from `toolbox.py` and the `Result` and `RequestData` classes from `types.py`. ```markdown # ToolBoxV2: Creating Modules ToolBoxV2 modules are Python files or packages that extend the framework's functionality. They can define simple functions, stateful tools (classes inheriting from `MainTool`), or API endpoints. ## Basic Module Structure A typical ToolBoxV2 module (`.py` file) includes: 1. **Imports:** Necessary libraries and ToolBoxV2 components. 2. **Module Metadata (Optional but Recommended):** * `Name` (or `name`): A string defining the module's canonical name. * `version`: A string for the module's version (e.g., \"1.0.0\"). 3. **Function/Class Definitions:** The core logic of your module. 4. **Exporting Functions:** Functions are made available to ToolBoxV2 using the `@export` decorator (which is an alias for `app.tb`). ## The `@export` Decorator (`app.tb`) The `@export` decorator is the primary mechanism for registering functions and configuring their behavior within ToolBoxV2. It's obtained from an `App` instance. ```python from toolboxv2 import get_app, App, Result, RequestData, MainTool from toolboxv2.utils.system.types import ToolBoxInterfaces # For specific interface types from typing import Optional, Dict, Any, List import asyncio # Get the application instance (singleton) # The 'prefix' for get_app here is often the module's own name, # though the decorator will use its 'mod_name' parameter. app = get_app(\"MyModule\") export = app.tb # Alias the decorator for convenience # --- Module Metadata (Best Practice) --- Name = \"MyModule\" # Used by the decorator if mod_name is not specified version = \"1.0.1\" # --- Example Functions --- @export(mod_name=Name, version=version, helper=\"A simple greeting function.\") def greet(name: str) -> str: \"\"\"Returns a greeting message.\"\"\" return f\"Hello, {name} from MyModule!\" @export(mod_name=Name, version=version, row=True, helper=\"Returns raw data without Result wrapping.\") def get_raw_data() -> dict: \"\"\"Demonstrates returning raw data.\"\"\" return {\"key\": \"value\", \"number\": 123} @export(mod_name=Name, version=version, initial=True, helper=\"Runs when the module is first loaded.\") def on_module_load(): \"\"\"Initialization logic for this module.\"\"\" app.print(f\"{Name} module has been loaded and initialized!\") # return Result.ok(info=\"MyModule initialized successfully\") # Optional: return a Result @export(mod_name=Name, version=version, exit_f=True, helper=\"Runs when the application is shutting down.\") async def on_module_exit(): \"\"\"Cleanup logic for this module.\"\"\" await asyncio.sleep(0.1) # Simulate async cleanup app.print(f\"{Name} module is cleaning up.\") # return Result.ok(info=\"MyModule cleaned up.\") # Optional @export(mod_name=Name, version=version, api=True, api_methods=['GET'], request_as_kwarg=True, helper=\"An example API endpoint.\") async def my_api_endpoint(request: Optional[RequestData] = None) -> Result: \"\"\" Handles GET requests to /api/MyModule/my_api_endpoint. Accesses request details if provided. \"\"\" if request: app.print(f\"API request received: {request.request.method} {request.request.path}\") app.print(f\"Query Params: {request.request.query_params}\") app.print(f\"User from session: {request.session.user_name}\") return Result.json(data={\"message\": \"API call successful!\", \"module_version\": version}) @export(mod_name=Name, version=version, memory_cache=True, memory_cache_ttl=60) def expensive_calculation(param: int) -> int: \"\"\" An example of a function whose results will be cached in memory for 60 seconds. \"\"\" app.print(f\"Performing expensive calculation for {param}...\") time.sleep(2) # Simulate work return param * param # Example of a more complex function using App instance and returning a Result @export(mod_name=Name, version=version) def process_data_with_app(app_instance: App, data_id: int) -> Result: \"\"\" This function automatically receives the 'App' instance if its first parameter is type-hinted as 'App'. This is determined by the 'state=True' logic in the decorator if 'app' is the first param. Alternatively, use state=False for stateless functions. \"\"\" if not isinstance(app_instance, App): # Should always be App if first param is 'app' return Result.default_internal_error(\"App instance not correctly passed.\") # Use app_instance for logging, accessing config, other modules, etc. app_instance.logger.info(f\"Processing data_id: {data_id} in {Name}\") if data_id < 0: return Result.default_user_error(info=\"Data ID cannot be negative.\") return Result.ok(data={\"processed_id\": data_id, \"status\": \"completed\"}) @export Decorator Parameters: \u00b6 name (str, optional): The name to register the function under. Defaults to the function's actual name. mod_name (str): The name of the module this function belongs to. If not provided, it tries to infer from func.__module__ or a global Name in the module. version (str, optional): Version string for this function/feature. Combined with the app's version. helper (str, optional): A docstring or help text for the function. api (bool, default False ): If True , exposes this function as an HTTP API endpoint. The URL pattern is typically /api/<mod_name>/<func_name> . For streaming, /sse/<mod_name>/<func_name> . api_methods (List[str], optional): Specifies allowed HTTP methods (e.g., ['GET', 'POST'] ). Defaults to ['AUTO'] (GET if no body params, POST if body params). request_as_kwarg (bool, default False ): If True and api=True , the function will receive a request: RequestData keyword argument if it's defined in its signature. row (bool, default False ): If True , the function's raw return value is used directly. If False (default), the return value is automatically wrapped in a Result.ok() object if it's not already a Result or ApiResult . initial (bool, default False ): If True , this function is added to the module's \"on_start\" list and is called when the module is loaded by the App instance (if the module instance is a MainTool or similar, or if called directly). exit_f (bool, default False ): If True , this function is added to the module's \"on_exit\" list and is called when the App instance is shutting down or the module is removed. state (bool, optional): If None (default): Automatically determined. If the first parameter of the decorated function is named self or app (and type-hinted as App ), state is considered True . Otherwise False . If True : The function is considered stateful. If its first parameter is self , it's assumed to be a method of a class instance (e.g., a MainTool subclass). If app , the App instance is passed. If False : The function is treated as stateless. test (bool, default True ): Marks the function as testable. Used by app.execute_all_functions() . samples (List[Dict[str, Any]], optional): A list of sample keyword arguments to be used when testing the function with app.execute_all_functions() . memory_cache (bool, default False ): Enables in-memory caching for the function's results. memory_cache_ttl (int, default 300 ): Time-to-live in seconds for memory cache entries. memory_cache_max_size (int, default 100 ): Max number of entries in the memory cache. file_cache (bool, default False ): Enables file-based caching for the function's results. (Stored in app.data_dir/cache/... ). restrict_in_virtual_mode (bool, default False ): If True , restricts function in certain virtualized/proxied modes. level (int, default -1 ): A general-purpose level or priority for the function. pre_compute (Callable, optional): A function (func, *args, **kwargs) -> (args, kwargs) called before the main function executes. It can modify args/kwargs. post_compute (Callable, optional): A function (result, func, *args, **kwargs) -> result called after the main function executes. It can modify the result. interface (ToolBoxInterfaces | str, optional): Specifies the intended interface type (e.g., ToolBoxInterfaces.cli , ToolBoxInterfaces.api ). Defaults to \"tb\". Result and ApiResult Objects \u00b6 Modules should typically return Result objects (or ApiResult for API endpoints) to provide standardized responses including success/error status, data payload, and informational messages. The toolboxv2.utils.system.types.Result class provides factory methods: Result.ok(data=..., info=...) Result.json(data=..., info=...) (for api=True functions) Result.html(data=..., info=...) Result.text(text_data=..., info=...) Result.binary(data=..., content_type=..., download_name=...) Result.redirect(url=..., status_code=...) Result.stream(stream_generator=..., info=..., cleanup_func=...) (for SSE) Result.default_user_error(info=..., exec_code=...) Result.default_internal_error(info=..., exec_code=...) Result.custom_error(data=..., info=..., exec_code=...) The Result object has a task(background_task_callable) method to schedule a background task to run after the main function returns. RequestData Object \u00b6 For API functions ( api=True ) with request_as_kwarg=True , if the function signature includes request: Optional[RequestData] = None , it will receive an instance of toolboxv2.utils.system.types.RequestData . RequestData provides access to: request.method , request.path request.headers (an instance of Headers , e.g., request.headers.user_agent , request.headers.hx_request ) request.query_params (dict) request.form_data (dict, if applicable) request.body (parsed JSON if content_type is application/json , otherwise raw bytes/str) session.SiID , session.user_name , session.level (from the current user's session) Creating a MainTool -based Module \u00b6 For more complex, stateful modules, you can create a class that inherits from toolboxv2.utils.system.main_tool.MainTool . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 from toolboxv2 import get_app , App , Result , MainTool from toolboxv2.utils.system.types import ToolBoxError app = get_app ( \"MyToolModule\" ) export = app . tb Name = \"MyToolModule\" version = \"0.5.0\" class Tools ( MainTool ): # The class must be named 'Tools' for auto-detection by older App versions # or ensure your module file directly uses @export on methods if not named Tools. # Or, you can export methods directly from any class: # class MyCustomTool(MainTool): # @export(...) # def my_method(self, ...): ... async def __ainit__ ( self ): # Asynchronous initialization # self.app is automatically available # self.name, self.version, self.logger are set by MainTool's __await__ await super () . __ainit__ ( name = Name , v = version , tool = { \"process_item\" : self . process_item , # For older compatibility if functions were in 'tools' dict \"get_status\" : self . get_status }) self . internal_state = \"initialized\" self . app . print ( f \" { self . name } (Tool) has been initialized with state: { self . internal_state } \" ) @export ( mod_name = Name , version = version ) # Decorate methods to export them def process_item ( self , item_id : int , details : str ) -> Result : # 'self' provides access to app, logger, name, version, config self . app . logger . info ( f \" { self . name } processing item: { item_id } - { details } \" ) self . internal_state = f \"last_processed_ { item_id } \" if item_id == 0 : return self . return_result ( # Helper from MainTool error = ToolBoxError . input_error , exec_code = 1 , # Custom error code help_text = \"Item ID cannot be zero.\" , data_info = \"Validation failed\" ) return Result . ok ( data = { \"item_id\" : item_id , \"status\" : \"processed by tool\" }) @export ( mod_name = Name , version = version ) async def get_status ( self ) -> str : # Example async method await asyncio . sleep ( 0.01 ) return f \"Tool { self . name } current state: { self . internal_state } \" async def on_exit ( self ): # Not automatically called unless also decorated or part of a convention self . app . print ( f \"Tool { self . name } is shutting down its internal state.\" ) # Perform cleanup # To ensure on_exit is called by the App framework: @export ( mod_name = Name , version = version , exit_f = True ) async def custom_tool_exit_function ( app_instance : App ): tool_instance = app_instance . get_mod ( Name ) if tool_instance and hasattr ( tool_instance , 'on_exit' ) and callable ( tool_instance . on_exit ): await tool_instance . on_exit () Key aspects of MainTool : * Asynchronous Initialization: Use async def __ainit__(self) for setup. The MainTool itself is awaitable, and __ainit__ is called when the instance is first awaited (e.g., by app.load_mod or app.get_mod ). * self.app : The App instance is available as self.app . * self.name , self.version , self.logger : These are automatically set up. * self.return_result(...) : A helper method for creating Result objects. * Methods intended to be called via app.run_any should be decorated with @export . Steps to Create a Valid Toolboxv2 Module: \u00b6 Define Module Structure: Organize your code with imports, metadata, and function/class definitions. Clarify Dependencies: Import necessary libraries. Handle missing optional dependencies gracefully if needed. Export Functions/Methods: Use the @export(...) decorator (e.g., app.tb(...) ) to mark functions/methods that ToolBoxV2 should recognize. Provide mod_name and version . Use other parameters ( api , row , initial , exit_f , memory_cache , etc.) as needed. Ensure clear signatures and document parameters/return types (Python type hints are highly recommended). Documentation and Versioning: Document your module and its functions. Use semantic versioning. Testing: Test your module thoroughly, including how it integrates with the ToolBoxV2 app ( app.run_any , app.get_mod , etc.). Use the test=True and samples parameters in @export to facilitate automated testing via app.execute_all_functions() .","title":"utils"},{"location":"utils/#toolboxv2-the-app-class","text":"The App class is the central singleton instance in ToolBoxV2, responsible for managing the application's lifecycle, configuration, module loading, and core functionalities. It's typically accessed via the get_app() utility function.","title":"ToolBoxV2: The App Class"},{"location":"utils/#initialization","text":"The App instance is initialized with a prefix and AppArgs (command-line arguments). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from toolboxv2 import App , AppArgs , get_app # Example: Initialize or get the App instance # The prefix helps differentiate multiple App instances if needed, # and is often used in directory naming. args = AppArgs () . default () # Or parsed from sys.argv in __main__.py app_instance = get_app ( prefix = \"my_app_instance\" , args = args ) # Accessing key attributes: print ( f \"App ID: { app_instance . id } \" ) print ( f \"Version: { app_instance . version } \" ) print ( f \"Start Directory: { app_instance . start_dir } \" ) print ( f \"Data Directory: { app_instance . data_dir } \" ) print ( f \"Config Directory: { app_instance . config_dir } \" ) print ( f \"Debug Mode: { app_instance . debug } \" )","title":"Initialization"},{"location":"utils/#key-initialization-steps","text":"System & Paths: Determines the operating system ( system_flag ). Sets the start_dir to the application's root directory. Resolves the prefix : If no prefix is provided, it attempts to load the last used prefix from .data/last-app-prefix.txt . If a prefix is provided, it's saved to this file for future use. Constructs the app_id (e.g., prefix-hostname ). Sets up data_dir , config_dir , and info_dir based on the app_id (e.g., ./.data/prefix-hostname/ ). Sets up appdata directory (OS-specific application data folder). Logging: Initializes a logger ( app.logger ). The logging level and output (terminal/file) can vary based on the prefix (e.g., \"test\", \"live\", \"debug\") and the --debug CLI argument. Configuration: Loads application configuration using FileHandler from a file typically named app_id.config in the config_dir . Defines default configuration keys and defaults (e.g., for macros, helpers, debug status). Core Attributes: version : ToolBoxV2 version, read from pyproject.toml . debug : Boolean, controlled by CLI args and config. dev_modi : Boolean, development mode status from config. functions : A dictionary to store registered functions from modules. modules : A dictionary to store loaded module objects. interface_type : Default ToolBoxInterfaces.native . alive : Boolean, controls the main application loop. args_sto : Stores the parsed AppArgs . loop : The asyncio event loop (initialized later or if already running). session : A Session object for managing user/remote session state. Conditional Actions (based on AppArgs ): args.init : If true, adds start_dir to sys.path . The __main__.py script handles other arguments like --update , --get-version , etc., by calling App methods or other utilities.","title":"Key Initialization Steps:"},{"location":"utils/#core-functionalities","text":"","title":"Core Functionalities"},{"location":"utils/#module-management","text":"load_mod(mod_name: str, spec='app', mlm='I', **kwargs) / save_load(modname, spec='app') : Loads a module into the application. spec (specification): Used to namespace or categorize the module instance (e.g., 'app' for general, or a specific session ID). Supports different loading mechanisms ( mlm ): 'I' : In-place load (imports the Python module directly). This is the default. 'C' : Copies the module file to a runtime directory before loading (less common). Handles ModuleNotFoundError by attempting to guide the user (e.g., install via CloudM or pip ). Registers the module's exported functions and/or its Tools class instance. Can reload modules if they are already loaded. 1 2 3 4 5 # Load the 'MyModule' my_module_instance = app_instance . load_mod ( \"MyModule\" ) # Or if it's a Tool-based module: # my_tool_instance = app_instance.load_mod(\"MyToolModule\") get_mod(name: str, spec='app') -> ModuleType | MainToolType : Retrieves a loaded module instance. If the module isn't loaded, it attempts to load it. 1 2 3 db_mod = app_instance . get_mod ( \"DB\" ) if db_mod : db_mod . some_db_function () remove_mod(mod_name: str, spec='app', delete=True) / a_remove_mod(...) (async): Unloads a module, calling its on_exit functions if defined. delete=True removes it completely from the functions registry. reload_mod(mod_name: str, spec='app', ...) : Reloads an existing module. Useful for development. watch_mod(mod_name: str, ...) : Monitors a module's source file(s) for changes and automatically reloads it. 1 2 # In development, watch 'MyDevModule' for changes app_instance . watch_mod ( \"MyDevModule\" ) load_all_mods_in_file(working_dir=\"mods\") / a_load_all_mods_in_file(...) (async): Scans the specified directory (default ./mods/ ) and loads all valid Python modules found.","title":"Module Management"},{"location":"utils/#function-registration-and-execution","text":"@app.tb(...) Decorator (via _create_decorator ): The primary way functions are registered with ToolBoxV2. See example_mod.md for details on usage. This decorator populates the app.functions dictionary. get_function(name: Enum | tuple, metadata=False, state=True, specification='app', ...) : Retrieves a registered function. name : Can be an Enum (from all_functions_enums.py ) or a (module_name, function_name) tuple. metadata=True : Returns a tuple (function_data_dict, callable_function) . state=True : Returns a stateful version of the function (bound to its module instance if applicable). state=False : Returns the raw, stateless function. specification : The context/instance spec to get the function for. run_any(mod_function_name, ..., get_results=False, **kwargs) / a_run_any(...) (async): Executes a registered function by its name (Enum or tuple). Handles argument passing, stateful/stateless execution, and error wrapping into a Result object. get_results=True : Returns the Result object itself. get_results=False (default): Returns the data payload from the Result object if successful. Automatically handles running the function's pre/post compute hooks and caching if configured via @app.tb . 1 2 3 4 5 6 # Synchronous execution result_data = app_instance . run_any (( \"MyModule\" , \"my_function\" ), arg1 = \"hello\" ) full_result_obj = app_instance . run_any (( \"MyModule\" , \"my_function\" ), arg1 = \"hello\" , get_results = True ) # Asynchronous execution async_result_data = await app_instance . a_run_any (( \"MyAsyncModule\" , \"my_async_function\" )) run_http(mod_function_name, function_name=None, method=\"GET\", ...) (async): Executes a function on a remote ToolBoxV2 instance via HTTP, using the app's session object.","title":"Function Registration and Execution"},{"location":"utils/#application-lifecycle","text":"exit() / a_exit() (async): Gracefully shuts down the application. Calls on_exit functions for all loaded modules. Saves configuration. Stops the main application loop ( alive = False ). Cleans up threads and the event loop if applicable.","title":"Application Lifecycle"},{"location":"utils/#utilities","text":"print(text, *args, **kwargs) / sprint(text, *args, **kwargs) : Styled print functions, prepending System$[app_id]: . sprint is often used for more verbose/system-level messages and can be silenced. debug_rains(e: Exception) : If app.debug is true, prints a full traceback and re-raises the exception. set_flows(r: dict) / run_flows(name: str, **kwargs) : Manages and executes predefined application flows (sequences of operations). get_username() / set_username(username: str) : Manages the application's user identity. save_autocompletion_dict() / get_autocompletion_dict() : Saves/loads a dictionary of modules and their functions for autocompletion features. save_registry_as_enums(directory: str, filename: str) : Generates an all_functions_enums.py -like file from the currently registered functions. execute_all_functions(...) / a_execute_all_functions(...) (async): Runs all registered testable functions (marked with test=True in @app.tb or having samples ). Useful for integration testing and profiling. Can filter by module ( m_query ) and function ( f_query ). Supports profiling via cProfile . run_bg_task(task: Callable) : Runs a synchronous or asynchronous task in a separate background thread with its own event loop. Ensures proper handling of nested asyncio operations within the task.","title":"Utilities"},{"location":"utils/#session-management-appsession","text":"The app.session attribute holds an instance of the Session class (from toolboxv2.utils.system.session ). It's used for: * Authenticating with a remote ToolBoxV2 service (e.g., SimpleCore Hub). * Making authenticated HTTP requests ( session.fetch , session.upload_file , session.download_file ). * Manages JWT claims and private key authentication. 1 2 3 4 # Example: Making an authenticated API call # Assumes app.session is already authenticated response_data = await app_instance . session . fetch ( \"/api/MyRemoteModule/get_info\" ) json_payload = await response_data . json () 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ### 2. `cli.md` - Documenting the Command Line Interface This should explain how to use the `tb` (or `python -m toolboxv2`) command-line tool, detailing its arguments and their effects. ```markdown # ToolBoxV2: Command Line Interface (CLI) ToolBoxV2 provides a command-line interface (CLI) for managing and running applications. It's typically invoked as `tb` (if installed globally or via an alias) or `python -m toolboxv2`. ## General Usage ```bash python -m toolboxv2 [options] [sub-commands] # or tb [options] [sub-commands] The CLI script ( __main__.py ) performs the following main steps: 1. Parses command-line arguments. 2. Initializes the App instance via setup_app() (which calls get_app() ). 3. Handles various options to: * Manage application data and configuration. * Control application modes (background, proxy, debug). * Load modules and manage their state. * Run tests or profilers. * Execute specific application flows or commands.","title":"Session Management (app.session)"},{"location":"utils/#key-cli-arguments","text":"The following are some of the primary arguments available. Use tb -h or python -m toolboxv2 -h for a full list. Instance and Mode: -init [name] : Initializes ToolBoxV2 with a specific instance name (default: main ). -n, --name <name> : Specifies an ID for the ToolBox instance (default: main ). This affects data/config directory names. -m, --modi <mode> : Starts a ToolBoxV2 interface/flow (e.g., cli , bg , or custom flows). Default is usually \"cli\". --debug : Starts the application in debug mode (more verbose logging, potentially different behavior). --remote : Starts in remote mode, often for connecting to a proxy or another instance. -bg, --background-application : Starts an interface in the background as a detached process. -bgr, --background-application-runner : Runs the background application logic in the current terminal (for daemons). -fg, --live-application : Starts a proxy interface, connecting to a background daemon. --kill : Kills the currently running local ToolBoxV2 instance (matching the -m <mode> and -n <name> ). Module and Version Management: -l, --load-all-mod-in-files : Loads all modules found in the mods/ directory on startup. -sfe, --save-function-enums-in-file : Generates/updates the all_functions_enums.py file based on loaded modules. Often used with -l . -v, --get-version : Prints the version of ToolBoxV2 and all loaded modules. -i, --install <name> : Installs a module or interface (likely via CloudM module). -r, --remove <name> : Uninstalls a module or interface. -u, --update <name_or_main> : Updates a module/interface or the core ToolBoxV2 ( main ). Development and Testing: --test : Runs all unit tests (typically discovers and runs tests in the tests/ directory). --profiler : Runs all registered testable functions and profiles their execution using cProfile . --ipy : Starts an IPython session with the ToolBoxV2 app pre-loaded. Provides magic commands like %tb save/loadX/load/open/inject . Service Management ( --sm ): Provides a sub-menu for managing ToolBoxV2 as a system service (Linux/systemd or Windows Startup). Options: Init, Start/Stop/Restart, Status, Uninstall, Show/Hide console window (Windows). Log Management ( --lm ): Provides a sub-menu for managing log files (e.g., removing or unstyling logs by date/level). Data and Configuration Management: --delete-config-all : Deletes all configuration files. Use with caution! --delete-data-all : Deletes all data folders. Use with caution! --delete-config : Deletes the configuration file for the named instance. --delete-data : Deletes the data folder for the named instance. Network Configuration (for interfaces): -p, --port <port> : Specifies the port for an interface (default: 5000 or 6587 for background). -w, --host <host> : Specifies the host for an interface (default: 0.0.0.0 ). Direct Command Execution: -c, --command <module_name> <function_name> [arg1 arg2 ...] (can be repeated): Executes a specific function. --kwargs <key=value> (can be repeated): Provides keyword arguments for commands specified with -c . Conda Integration: conda [conda_args...] : Special argument to pass commands directly to a conda_runner.py script (e.g., tb conda env list ). API Runner: api [api_args...] : Special argument to invoke cli_api_runner.py , likely for direct API interactions or testing. GUI: gui : Starts the GUI version of ToolBoxV2 (imports and runs toolboxv2.__gui__.start ).","title":"Key CLI Arguments"},{"location":"utils/#cli-execution-flow-__main__py","text":"Argument Parsing: parse_args() uses argparse to define and parse all CLI arguments. App Setup ( setup_app() ): Initializes the App instance using get_app() with the parsed arguments and name. Sets up PID file for the current process. Optionally silences app.sprint if not in debug/verbose mode. Loads all modules if -l is specified. Handles --update logic. Background/Live Application Handling: If -bgr : Initializes DaemonApp . If -bg : Starts the application as a detached background process using subprocess.Popen . If -fg (live-application): Attempts to connect to a background daemon using ProxyApp . Action Dispatching: Based on the parsed arguments, it performs actions like: Module installation ( --install ). Log management ( --lm ). Service management ( --sm ). Saving function enums ( -sfe ). Printing versions ( -v ). Running the profiler ( --profiler ). Running flows based on --modi . Handling Docker commands ( --docker ). Killing an existing instance ( --kill ). Executing direct commands ( -c ). Cleanup: Removes the PID file and calls app.a_exit() before exiting.","title":"CLI Execution Flow (__main__.py)"},{"location":"utils/#example-cli-usage","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Get version information python -m toolboxv2 -v # Load all modules and save function enums python -m toolboxv2 -l -sfe # Run a specific function in MyModule python -m toolboxv2 -c MyModule my_function arg_value --kwargs param_name = kwarg_value # Start the application with a custom flow named 'web_server' in debug mode python -m toolboxv2 -m web_server --debug -n my_web_instance # Start a background daemon for the 'bg_processing' flow python -m toolboxv2 -m bg_processing -bg -n background_processor # Connect to the background daemon with a live proxy application python -m toolboxv2 -m cli -fg -n background_processor # Kill the 'web_server' modi instance named 'my_web_instance' python -m toolboxv2 -m web_server --kill -n my_web_instance 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 ### 3. `example_mod.md` - Documenting Module Creation This needs to be updated to accurately reflect the `@app.tb(...)` decorator from `toolbox.py` and the `Result` and `RequestData` classes from `types.py`. ```markdown # ToolBoxV2: Creating Modules ToolBoxV2 modules are Python files or packages that extend the framework's functionality. They can define simple functions, stateful tools (classes inheriting from `MainTool`), or API endpoints. ## Basic Module Structure A typical ToolBoxV2 module (`.py` file) includes: 1. **Imports:** Necessary libraries and ToolBoxV2 components. 2. **Module Metadata (Optional but Recommended):** * `Name` (or `name`): A string defining the module's canonical name. * `version`: A string for the module's version (e.g., \"1.0.0\"). 3. **Function/Class Definitions:** The core logic of your module. 4. **Exporting Functions:** Functions are made available to ToolBoxV2 using the `@export` decorator (which is an alias for `app.tb`). ## The `@export` Decorator (`app.tb`) The `@export` decorator is the primary mechanism for registering functions and configuring their behavior within ToolBoxV2. It's obtained from an `App` instance. ```python from toolboxv2 import get_app, App, Result, RequestData, MainTool from toolboxv2.utils.system.types import ToolBoxInterfaces # For specific interface types from typing import Optional, Dict, Any, List import asyncio # Get the application instance (singleton) # The 'prefix' for get_app here is often the module's own name, # though the decorator will use its 'mod_name' parameter. app = get_app(\"MyModule\") export = app.tb # Alias the decorator for convenience # --- Module Metadata (Best Practice) --- Name = \"MyModule\" # Used by the decorator if mod_name is not specified version = \"1.0.1\" # --- Example Functions --- @export(mod_name=Name, version=version, helper=\"A simple greeting function.\") def greet(name: str) -> str: \"\"\"Returns a greeting message.\"\"\" return f\"Hello, {name} from MyModule!\" @export(mod_name=Name, version=version, row=True, helper=\"Returns raw data without Result wrapping.\") def get_raw_data() -> dict: \"\"\"Demonstrates returning raw data.\"\"\" return {\"key\": \"value\", \"number\": 123} @export(mod_name=Name, version=version, initial=True, helper=\"Runs when the module is first loaded.\") def on_module_load(): \"\"\"Initialization logic for this module.\"\"\" app.print(f\"{Name} module has been loaded and initialized!\") # return Result.ok(info=\"MyModule initialized successfully\") # Optional: return a Result @export(mod_name=Name, version=version, exit_f=True, helper=\"Runs when the application is shutting down.\") async def on_module_exit(): \"\"\"Cleanup logic for this module.\"\"\" await asyncio.sleep(0.1) # Simulate async cleanup app.print(f\"{Name} module is cleaning up.\") # return Result.ok(info=\"MyModule cleaned up.\") # Optional @export(mod_name=Name, version=version, api=True, api_methods=['GET'], request_as_kwarg=True, helper=\"An example API endpoint.\") async def my_api_endpoint(request: Optional[RequestData] = None) -> Result: \"\"\" Handles GET requests to /api/MyModule/my_api_endpoint. Accesses request details if provided. \"\"\" if request: app.print(f\"API request received: {request.request.method} {request.request.path}\") app.print(f\"Query Params: {request.request.query_params}\") app.print(f\"User from session: {request.session.user_name}\") return Result.json(data={\"message\": \"API call successful!\", \"module_version\": version}) @export(mod_name=Name, version=version, memory_cache=True, memory_cache_ttl=60) def expensive_calculation(param: int) -> int: \"\"\" An example of a function whose results will be cached in memory for 60 seconds. \"\"\" app.print(f\"Performing expensive calculation for {param}...\") time.sleep(2) # Simulate work return param * param # Example of a more complex function using App instance and returning a Result @export(mod_name=Name, version=version) def process_data_with_app(app_instance: App, data_id: int) -> Result: \"\"\" This function automatically receives the 'App' instance if its first parameter is type-hinted as 'App'. This is determined by the 'state=True' logic in the decorator if 'app' is the first param. Alternatively, use state=False for stateless functions. \"\"\" if not isinstance(app_instance, App): # Should always be App if first param is 'app' return Result.default_internal_error(\"App instance not correctly passed.\") # Use app_instance for logging, accessing config, other modules, etc. app_instance.logger.info(f\"Processing data_id: {data_id} in {Name}\") if data_id < 0: return Result.default_user_error(info=\"Data ID cannot be negative.\") return Result.ok(data={\"processed_id\": data_id, \"status\": \"completed\"})","title":"Example CLI Usage"},{"location":"utils/#export-decorator-parameters","text":"name (str, optional): The name to register the function under. Defaults to the function's actual name. mod_name (str): The name of the module this function belongs to. If not provided, it tries to infer from func.__module__ or a global Name in the module. version (str, optional): Version string for this function/feature. Combined with the app's version. helper (str, optional): A docstring or help text for the function. api (bool, default False ): If True , exposes this function as an HTTP API endpoint. The URL pattern is typically /api/<mod_name>/<func_name> . For streaming, /sse/<mod_name>/<func_name> . api_methods (List[str], optional): Specifies allowed HTTP methods (e.g., ['GET', 'POST'] ). Defaults to ['AUTO'] (GET if no body params, POST if body params). request_as_kwarg (bool, default False ): If True and api=True , the function will receive a request: RequestData keyword argument if it's defined in its signature. row (bool, default False ): If True , the function's raw return value is used directly. If False (default), the return value is automatically wrapped in a Result.ok() object if it's not already a Result or ApiResult . initial (bool, default False ): If True , this function is added to the module's \"on_start\" list and is called when the module is loaded by the App instance (if the module instance is a MainTool or similar, or if called directly). exit_f (bool, default False ): If True , this function is added to the module's \"on_exit\" list and is called when the App instance is shutting down or the module is removed. state (bool, optional): If None (default): Automatically determined. If the first parameter of the decorated function is named self or app (and type-hinted as App ), state is considered True . Otherwise False . If True : The function is considered stateful. If its first parameter is self , it's assumed to be a method of a class instance (e.g., a MainTool subclass). If app , the App instance is passed. If False : The function is treated as stateless. test (bool, default True ): Marks the function as testable. Used by app.execute_all_functions() . samples (List[Dict[str, Any]], optional): A list of sample keyword arguments to be used when testing the function with app.execute_all_functions() . memory_cache (bool, default False ): Enables in-memory caching for the function's results. memory_cache_ttl (int, default 300 ): Time-to-live in seconds for memory cache entries. memory_cache_max_size (int, default 100 ): Max number of entries in the memory cache. file_cache (bool, default False ): Enables file-based caching for the function's results. (Stored in app.data_dir/cache/... ). restrict_in_virtual_mode (bool, default False ): If True , restricts function in certain virtualized/proxied modes. level (int, default -1 ): A general-purpose level or priority for the function. pre_compute (Callable, optional): A function (func, *args, **kwargs) -> (args, kwargs) called before the main function executes. It can modify args/kwargs. post_compute (Callable, optional): A function (result, func, *args, **kwargs) -> result called after the main function executes. It can modify the result. interface (ToolBoxInterfaces | str, optional): Specifies the intended interface type (e.g., ToolBoxInterfaces.cli , ToolBoxInterfaces.api ). Defaults to \"tb\".","title":"@export Decorator Parameters:"},{"location":"utils/#result-and-apiresult-objects","text":"Modules should typically return Result objects (or ApiResult for API endpoints) to provide standardized responses including success/error status, data payload, and informational messages. The toolboxv2.utils.system.types.Result class provides factory methods: Result.ok(data=..., info=...) Result.json(data=..., info=...) (for api=True functions) Result.html(data=..., info=...) Result.text(text_data=..., info=...) Result.binary(data=..., content_type=..., download_name=...) Result.redirect(url=..., status_code=...) Result.stream(stream_generator=..., info=..., cleanup_func=...) (for SSE) Result.default_user_error(info=..., exec_code=...) Result.default_internal_error(info=..., exec_code=...) Result.custom_error(data=..., info=..., exec_code=...) The Result object has a task(background_task_callable) method to schedule a background task to run after the main function returns.","title":"Result and ApiResult Objects"},{"location":"utils/#requestdata-object","text":"For API functions ( api=True ) with request_as_kwarg=True , if the function signature includes request: Optional[RequestData] = None , it will receive an instance of toolboxv2.utils.system.types.RequestData . RequestData provides access to: request.method , request.path request.headers (an instance of Headers , e.g., request.headers.user_agent , request.headers.hx_request ) request.query_params (dict) request.form_data (dict, if applicable) request.body (parsed JSON if content_type is application/json , otherwise raw bytes/str) session.SiID , session.user_name , session.level (from the current user's session)","title":"RequestData Object"},{"location":"utils/#creating-a-maintool-based-module","text":"For more complex, stateful modules, you can create a class that inherits from toolboxv2.utils.system.main_tool.MainTool . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 from toolboxv2 import get_app , App , Result , MainTool from toolboxv2.utils.system.types import ToolBoxError app = get_app ( \"MyToolModule\" ) export = app . tb Name = \"MyToolModule\" version = \"0.5.0\" class Tools ( MainTool ): # The class must be named 'Tools' for auto-detection by older App versions # or ensure your module file directly uses @export on methods if not named Tools. # Or, you can export methods directly from any class: # class MyCustomTool(MainTool): # @export(...) # def my_method(self, ...): ... async def __ainit__ ( self ): # Asynchronous initialization # self.app is automatically available # self.name, self.version, self.logger are set by MainTool's __await__ await super () . __ainit__ ( name = Name , v = version , tool = { \"process_item\" : self . process_item , # For older compatibility if functions were in 'tools' dict \"get_status\" : self . get_status }) self . internal_state = \"initialized\" self . app . print ( f \" { self . name } (Tool) has been initialized with state: { self . internal_state } \" ) @export ( mod_name = Name , version = version ) # Decorate methods to export them def process_item ( self , item_id : int , details : str ) -> Result : # 'self' provides access to app, logger, name, version, config self . app . logger . info ( f \" { self . name } processing item: { item_id } - { details } \" ) self . internal_state = f \"last_processed_ { item_id } \" if item_id == 0 : return self . return_result ( # Helper from MainTool error = ToolBoxError . input_error , exec_code = 1 , # Custom error code help_text = \"Item ID cannot be zero.\" , data_info = \"Validation failed\" ) return Result . ok ( data = { \"item_id\" : item_id , \"status\" : \"processed by tool\" }) @export ( mod_name = Name , version = version ) async def get_status ( self ) -> str : # Example async method await asyncio . sleep ( 0.01 ) return f \"Tool { self . name } current state: { self . internal_state } \" async def on_exit ( self ): # Not automatically called unless also decorated or part of a convention self . app . print ( f \"Tool { self . name } is shutting down its internal state.\" ) # Perform cleanup # To ensure on_exit is called by the App framework: @export ( mod_name = Name , version = version , exit_f = True ) async def custom_tool_exit_function ( app_instance : App ): tool_instance = app_instance . get_mod ( Name ) if tool_instance and hasattr ( tool_instance , 'on_exit' ) and callable ( tool_instance . on_exit ): await tool_instance . on_exit () Key aspects of MainTool : * Asynchronous Initialization: Use async def __ainit__(self) for setup. The MainTool itself is awaitable, and __ainit__ is called when the instance is first awaited (e.g., by app.load_mod or app.get_mod ). * self.app : The App instance is available as self.app . * self.name , self.version , self.logger : These are automatically set up. * self.return_result(...) : A helper method for creating Result objects. * Methods intended to be called via app.run_any should be decorated with @export .","title":"Creating a MainTool-based Module"},{"location":"utils/#steps-to-create-a-valid-toolboxv2-module","text":"Define Module Structure: Organize your code with imports, metadata, and function/class definitions. Clarify Dependencies: Import necessary libraries. Handle missing optional dependencies gracefully if needed. Export Functions/Methods: Use the @export(...) decorator (e.g., app.tb(...) ) to mark functions/methods that ToolBoxV2 should recognize. Provide mod_name and version . Use other parameters ( api , row , initial , exit_f , memory_cache , etc.) as needed. Ensure clear signatures and document parameters/return types (Python type hints are highly recommended). Documentation and Versioning: Document your module and its functions. Use semantic versioning. Testing: Test your module thoroughly, including how it integrates with the ToolBoxV2 app ( app.run_any , app.get_mod , etc.). Use the test=True and samples parameters in @export to facilitate automated testing via app.execute_all_functions() .","title":"Steps to Create a Valid Toolboxv2 Module:"},{"location":"webinfos/","text":"","title":"Webinfos"}]}